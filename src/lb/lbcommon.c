#include <lb/library.h>
#include <ft/fighter.h>
#include <gr/ground.h>
#include <sys/system_00.h>

extern void hal_interpolation_cubic(void*, void*, f32);
extern void* func_80026A10_27610(u16);

extern u16 gSinTable[/* */];

// // // // // // // // // // // //
//                               //
//   GLOBAL / STATIC VARIABLES   //
//                               //
// // // // // // // // // // // //

extern u16 sLBCommonExternSpriteAttr;
extern u16 sLBCommonExternBitmapFmt;
extern void *sLBCommonPrevBitmapBuf;
extern void *sLBCommonPrevSpriteLUT;
extern s32 sLBCommonScissorXMax;
extern s32 sLBCommonScissorYMax;
extern s32 sLBCommonScissorXMin;
extern s32 sLBCommonScissorYMin;

extern Vec3f D_800D62D0;

// // // // // // // // // // // //
//                               //
//       INITIALIZED DATA        //
//                               //
// // // // // // // // // // // //

// 0x800D4CA0
f32 dLBCommonSinLookup[/* */] =
{
	0.000000000000000, 0.001534000039101, 0.003068000078201, 0.004602000117302,
	0.006136000156403, 0.007670000195503, 0.009204000234604, 0.010738000273705,
	0.012272000312805, 0.013805000111461, 0.015339000150561, 0.016873000189662,
	0.018407000228763, 0.019940000027418, 0.021474000066519, 0.023008000105619,
	0.024540999904275, 0.026074999943376, 0.027607999742031, 0.029141999781132,
	0.030674999579787, 0.032207999378443, 0.033741001039743, 0.035273998975754,
	0.036807000637054, 0.038339998573065, 0.039873000234365, 0.041405998170376,
	0.042938001453876, 0.044470999389887, 0.046002998948097, 0.047534998506308,
	0.049068000167608, 0.050599999725819, 0.052131999284029, 0.053663998842239,
	0.055195000022650, 0.056726999580860, 0.058258000761271, 0.059790000319481,
	0.061321001499891, 0.062852002680302, 0.064383000135422, 0.065912999212742,
	0.067443996667862, 0.068974003195763, 0.070505000650883, 0.072034999728203,
	0.073564998805523, 0.075093999505043, 0.076623998582363, 0.078152999281883,
	0.079681999981403, 0.081211000680923, 0.082740001380444, 0.084269002079964,
	0.085796996951103, 0.087325997650623, 0.088853999972343, 0.090380996465683,
	0.091908998787403, 0.093436002731323, 0.094962999224663, 0.096490003168583,
	0.098016999661922, 0.099544003605843, 0.101070001721382, 0.102595999836922,
	0.104121997952461, 0.105646997690201, 0.107171997427940, 0.108696997165680,
	0.110221996903419, 0.111746996641159, 0.113270998001099, 0.114794999361038,
	0.116319000720978, 0.117842003703117, 0.119364999234676, 0.120888002216816,
	0.122410997748375, 0.123933002352715, 0.125455006957054, 0.126976996660233,
	0.128498002886772, 0.130018994212151, 0.131540000438690, 0.133061006665230,
	0.134580999612808, 0.136100992560387, 0.137620002031326, 0.139138996601105,
	0.140658006072044, 0.142177000641823, 0.143694996833801, 0.145212993025780,
	0.146730005741119, 0.148248001933098, 0.149764999747276, 0.151280999183655,
	0.152796998620033, 0.154312998056412, 0.155827999114990, 0.157343000173569,
	0.158858001232147, 0.160372003912926, 0.161886006593704, 0.163399994373322,
	0.164912998676300, 0.166426002979279, 0.167937994003296, 0.169449999928474,
	0.170962005853653, 0.172472998499870, 0.173984006047249, 0.175494000315666,
	0.177003994584084, 0.178514003753662, 0.180022999644279, 0.181531995534897,
	0.183039993047714, 0.184548005461693, 0.186055004596710, 0.187562003731728,
	0.189069002866745, 0.190575003623962, 0.192080006003380, 0.193586006760597,
	0.195089995861053, 0.196594998240471, 0.198098003864288, 0.199601992964745,
	0.201104998588562, 0.202607005834579, 0.204108998179436, 0.205610007047653,
	0.207111001014709, 0.208611994981766, 0.210112005472183, 0.211611002683640,
	0.213109999895096, 0.214608997106552, 0.216106995940208, 0.217603996396065,
	0.219100996851921, 0.220597997307777, 0.222093999385834, 0.223589003086090,
	0.225084006786346, 0.226577997207642, 0.228072002530098, 0.229564994573593,
	0.231058001518250, 0.232549995183945, 0.234042003750801, 0.235532999038696,
	0.237023994326591, 0.238514006137848, 0.240003004670143, 0.241492003202438,
	0.242980003356934, 0.244468003511429, 0.245955005288124, 0.247442007064819,
	0.248927995562553, 0.250413000583649, 0.251897990703583, 0.253381997346878,
	0.254866003990173, 0.256348997354507, 0.257831007242203, 0.259312987327576,
	0.260794013738632, 0.262275010347366, 0.263754993677139, 0.265233993530273,
	0.266712993383408, 0.268191009759903, 0.269668012857437, 0.271144986152649,
	0.272621005773544, 0.274096995592117, 0.275572001934052, 0.277045994997025,
	0.278519988059998, 0.279992997646332, 0.281464993953705, 0.282936990261078,
	0.284408003091812, 0.285878002643585, 0.287346988916397, 0.288816004991531,
	0.290284991264343, 0.291752010583878, 0.293219000101089, 0.294685006141663,
	0.296151012182236, 0.297616004943848, 0.299080014228821, 0.300543010234833,
	0.302006006240845, 0.303467988967896, 0.304928988218307, 0.306389987468719,
	0.307850003242493, 0.309309005737305, 0.310766994953156, 0.312225013971329,
	0.313681989908218, 0.315138012170792, 0.316592991352081, 0.318048000335693,
	0.319501996040344, 0.320955008268356, 0.322407990694046, 0.323859006166458,
	0.325309991836548, 0.326759994029999, 0.328209996223450, 0.329658001661301,
	0.331106007099152, 0.332552999258041, 0.333999991416931, 0.335444986820221,
	0.336890012025833, 0.338333994150162, 0.339776992797852, 0.341219007968903,
	0.342660993337631, 0.344101011753082, 0.345541000366211, 0.346980005502701,
	0.348419010639191, 0.349855989217758, 0.351292997598648, 0.352728992700577,
	0.354164004325867, 0.355598002672195, 0.357030987739563, 0.358462989330292,
	0.359894990921021, 0.361326009035110, 0.362756013870239, 0.364185005426407,
	0.365613013505936, 0.367040008306503, 0.368467003107071, 0.369892001152039,
	0.371316999197006, 0.372741013765335, 0.374163985252380, 0.375586003065109,
	0.377007007598877, 0.378428012132645, 0.379846990108490, 0.381265997886658,
	0.382683008909225, 0.384099990129471, 0.385515987873077, 0.386931002140045,
	0.388345003128052, 0.389757990837097, 0.391169995069504, 0.392581999301910,
	0.393992006778717, 0.395401000976562, 0.396809995174408, 0.398218005895615,
	0.399623990058899, 0.401030004024506, 0.402435004711151, 0.403838008642197,
	0.405241012573242, 0.406643003225327, 0.408044010400772, 0.409444004297256,
	0.410843014717102, 0.412241011857986, 0.413637995719910, 0.415033996105194,
	0.416429996490479, 0.417824000120163, 0.419216990470886, 0.420608997344971,
	0.421999990940094, 0.423390001058578, 0.424780011177063, 0.426167994737625,
	0.427554994821548, 0.428941011428833, 0.430326014757156, 0.431710988283157,
	0.433093994855881, 0.434475988149643, 0.435856997966766, 0.437236994504929,
	0.438616007566452, 0.439994007349014, 0.441370993852615, 0.442746996879578,
	0.444121986627579, 0.445495992898941, 0.446868985891342, 0.448240995407104,
	0.449611008167267, 0.450980991125107, 0.452349990606308, 0.453716993331909,
	0.455083996057510, 0.456449002027512, 0.457812994718552, 0.459176987409592,
	0.460539013147354, 0.461899995803833, 0.463259994983673, 0.464619010686874,
	0.465977013111115, 0.467332988977432, 0.468688994646072, 0.470043003559113,
	0.471397012472153, 0.472748994827271, 0.474099993705750, 0.475450009107590,
	0.476799011230469, 0.478147000074387, 0.479494005441666, 0.480839014053345,
	0.482183992862701, 0.483527004718781, 0.484869003295898, 0.486209988594055,
	0.487549990415573, 0.488889008760452, 0.490227013826370, 0.491562992334366,
	0.492897987365723, 0.494231998920441, 0.495564997196198, 0.496897011995316,
	0.498228013515472, 0.499556988477707, 0.500885009765625, 0.502211987972260,
	0.503538012504578, 0.504863023757935, 0.506187021732330, 0.507508993148804,
	0.508830010890961, 0.510150015354156, 0.511469006538391, 0.512785971164703,
	0.514102995395660, 0.515417993068695, 0.516731977462769, 0.518045008182526,
	0.519356012344360, 0.520666003227234, 0.521974980831146, 0.523283004760742,
	0.524590015411377, 0.525894999504089, 0.527198970317841, 0.528501987457275,
	0.529803991317749, 0.531104028224945, 0.532402992248535, 0.533701002597809,
	0.534997999668121, 0.536293029785156, 0.537586987018585, 0.538879990577698,
	0.540171980857849, 0.541462004184723, 0.542751014232635, 0.544039011001587,
	0.545324981212616, 0.546609997749329, 0.547894001007080, 0.549176990985870,
	0.550458014011383, 0.551738023757935, 0.553017020225525, 0.554293990135193,
	0.555570006370544, 0.556845009326935, 0.558118999004364, 0.559391021728516,
	0.560661971569061, 0.561931014060974, 0.563198983669281, 0.564465999603271,
	0.565732002258301, 0.566995978355408, 0.568259000778198, 0.569521009922028,
	0.570780992507935, 0.572040021419525, 0.573297023773193, 0.574553012847900,
	0.575807988643646, 0.577062010765076, 0.578314006328583, 0.579564988613129,
	0.580814003944397, 0.582062005996704, 0.583308994770050, 0.584554016590118,
	0.585798025131226, 0.587040007114410, 0.588281989097595, 0.589520990848541,
	0.590759992599487, 0.591997027397156, 0.593231976032257, 0.594466984272003,
	0.595699012279510, 0.596930980682373, 0.598160982131958, 0.599389016628265,
	0.600615978240967, 0.601841986179352, 0.603066980838776, 0.604290008544922,
	0.605511009693146, 0.606730997562408, 0.607949972152710, 0.609166979789734,
	0.610382974147797, 0.611597001552582, 0.612810015678406, 0.614022016525269,
	0.615231990814209, 0.616439998149872, 0.617646992206573, 0.618852972984314,
	0.620056986808777, 0.621259987354279, 0.622461020946503, 0.623660981655121,
	0.624859988689423, 0.626056015491486, 0.627251982688904, 0.628445982933044,
	0.629638016223907, 0.630828976631165, 0.632018983364105, 0.633207023143768,
	0.634392976760864, 0.635577976703644, 0.636762022972107, 0.637943983078003,
	0.639123976230621, 0.640303015708923, 0.641480982303619, 0.642656981945038,
	0.643832027912140, 0.645004987716675, 0.646175980567932, 0.647346019744873,
	0.648513972759247, 0.649680972099304, 0.650847017765045, 0.652010977268219,
	0.653173029422760, 0.654334008693695, 0.655493021011353, 0.656651020050049,
	0.657806992530823, 0.658960998058319, 0.660113990306854, 0.661266028881073,
	0.662415981292725, 0.663564026355743, 0.664710998535156, 0.665856003761292,
	0.666999995708466, 0.668142020702362, 0.669282972812653, 0.670422017574310,
	0.671558976173401, 0.672694981098175, 0.673829019069672, 0.674961984157562,
	0.676092982292175, 0.677222013473511, 0.678349971771240, 0.679476022720337,
	0.680601000785828, 0.681724011898041, 0.682846009731293, 0.683965027332306,
	0.685083985328674, 0.686200022697449, 0.687314987182617, 0.688428997993469,
	0.689540982246399, 0.690650999546051, 0.691758990287781, 0.692866027355194,
	0.693971991539001, 0.695074975490570, 0.696177005767822, 0.697277009487152,
	0.698375999927521, 0.699473023414612, 0.700568974018097, 0.701663017272949,
	0.702754974365234, 0.703845024108887, 0.704934000968933, 0.706021010875702,
	0.707107007503510, 0.708190977573395, 0.709272980690002, 0.710353016853333,
	0.711431980133057, 0.712508976459503, 0.713585019111633, 0.714658975601196,
	0.715731024742126, 0.716800987720490, 0.717869997024536, 0.718936979770660,
	0.720003008842468, 0.721065998077393, 0.722127974033356, 0.723188996315002,
	0.724246978759766, 0.725304007530212, 0.726359009742737, 0.727412998676300,
	0.728464007377625, 0.729514002799988, 0.730562984943390, 0.731608986854553,
	0.732653975486755, 0.733696997165680, 0.734739005565643, 0.735778987407684,
	0.736817002296448, 0.737852990627289, 0.738887012004852, 0.739920020103455,
	0.740951001644135, 0.741980016231537, 0.743008017539978, 0.744033992290497,
	0.745058000087738, 0.746079981327057, 0.747101008892059, 0.748118996620178,
	0.749135971069336, 0.750151991844177, 0.751164972782135, 0.752177000045776,
	0.753187000751495, 0.754194974899292, 0.755200982093811, 0.756205976009369,
	0.757209002971649, 0.758210003376007, 0.759208977222443, 0.760206997394562,
	0.761201977729797, 0.762196004390717, 0.763188004493713, 0.764178991317749,
	0.765166997909546, 0.766153991222382, 0.767139017581940, 0.768122017383575,
	0.769102990627289, 0.770083010196686, 0.771061003208160, 0.772036015987396,
	0.773010015487671, 0.773983001708984, 0.774953007698059, 0.775922000408173,
	0.776888012886047, 0.777853012084961, 0.778816998004913, 0.779778003692627,
	0.780736982822418, 0.781695008277893, 0.782651007175446, 0.783604979515076,
	0.784556984901428, 0.785507023334503, 0.786454975605011, 0.787401974201202,
	0.788345992565155, 0.789288997650146, 0.790229976177216, 0.791168987751007,
	0.792106986045837, 0.793042004108429, 0.793974995613098, 0.794906973838806,
	0.795836985111237, 0.796765029430389, 0.797690987586975, 0.798614978790283,
	0.799537003040314, 0.800458014011383, 0.801375985145569, 0.802293002605438,
	0.803207993507385, 0.804120004177094, 0.805031001567841, 0.805939972400665,
	0.806847989559174, 0.807753026485443, 0.808655977249146, 0.809557974338531,
	0.810456991195679, 0.811354994773865, 0.812250971794128, 0.813144028186798,
	0.814036011695862, 0.814926028251648, 0.815814018249512, 0.816700994968414,
	0.817584991455078, 0.818467020988464, 0.819347977638245, 0.820226013660431,
	0.821102023124695, 0.821977019309998, 0.822849988937378, 0.823720991611481,
	0.824589014053345, 0.825456023216248, 0.826321005821228, 0.827184021472931,
	0.828045010566711, 0.828903973102570, 0.829761028289795, 0.830615997314453,
	0.831470012664795, 0.832320988178253, 0.833169996738434, 0.834017992019653,
	0.834863007068634, 0.835705995559692, 0.836547970771790, 0.837387025356293,
	0.838225007057190, 0.839060008525848, 0.839893996715546, 0.840725004673004,
	0.841554999351501, 0.842383027076721, 0.843208014965057, 0.844031989574432,
	0.844853997230530, 0.845673024654388, 0.846490979194641, 0.847307026386261,
	0.848119974136353, 0.848932027816772, 0.849741995334625, 0.850549995899200,
	0.851355016231537, 0.852159023284912, 0.852961003780365, 0.853760004043579,
	0.854557991027832, 0.855354011058807, 0.856146991252899, 0.856939017772675,
	0.857729017734528, 0.858515977859497, 0.859301984310150, 0.860085010528564,
	0.860867023468018, 0.861645996570587, 0.862424015998840, 0.863198995590210,
	0.863973021507263, 0.864744007587433, 0.865513980388641, 0.866280972957611,
	0.867045998573303, 0.867808997631073, 0.868570983409882, 0.869329988956451,
	0.870087027549744, 0.870841979980469, 0.871595025062561, 0.872345983982086,
	0.873094975948334, 0.873842000961304, 0.874586999416351, 0.875329017639160,
	0.876070022583008, 0.876809000968933, 0.877544999122620, 0.878279983997345,
	0.879011988639832, 0.879742980003357, 0.880470991134644, 0.881196975708008,
	0.881920993328094, 0.882642984390259, 0.883363008499146, 0.884081006050110,
	0.884796977043152, 0.885510981082916, 0.886223018169403, 0.886932015419006,
	0.887639999389648, 0.888345003128052, 0.889047980308533, 0.889750003814697,
	0.890448987483978, 0.891146004199982, 0.891840994358063, 0.892534017562866,
	0.893224000930786, 0.893912971019745, 0.894599020481110, 0.895283997058868,
	0.895965993404388, 0.896646022796631, 0.897324979305267, 0.898001015186310,
	0.898674011230469, 0.899345993995667, 0.900016009807587, 0.900682985782623,
	0.901349008083344, 0.902011990547180, 0.902673006057739, 0.903331995010376,
	0.903989017009735, 0.904644012451172, 0.905296981334686, 0.905947029590607,
	0.906596004962921, 0.907242000102997, 0.907886028289795, 0.908527970314026,
	0.909168004989624, 0.909806013107300, 0.910440981388092, 0.911074995994568,
	0.911705970764160, 0.912334978580475, 0.912962019443512, 0.913586974143982,
	0.914210021495819, 0.914830029010773, 0.915449023246765, 0.916064977645874,
	0.916679024696350, 0.917290985584259, 0.917900979518890, 0.918507993221283,
	0.919113993644714, 0.919717013835907, 0.920318007469177, 0.920916974544525,
	0.921513974666595, 0.922109007835388, 0.922701001167297, 0.923291027545929,
	0.923879981040955, 0.924465000629425, 0.925049006938934, 0.925630986690521,
	0.926209986209869, 0.926787018775940, 0.927362978458405, 0.927935004234314,
	0.928506016731262, 0.929075002670288, 0.929641008377075, 0.930204987525940,
	0.930766999721527, 0.931326985359192, 0.931883990764618, 0.932439982891083,
	0.932992994785309, 0.933543980121613, 0.934092998504639, 0.934638977050781,
	0.935184001922607, 0.935725986957550, 0.936266005039215, 0.936802983283997,
	0.937339007854462, 0.937871992588043, 0.938404023647308, 0.938932001590729,
	0.939459025859833, 0.939984023571014, 0.940505981445312, 0.941025972366333,
	0.941543996334076, 0.942059993743896, 0.942573010921478, 0.943084001541138,
	0.943593978881836, 0.944100022315979, 0.944604992866516, 0.945106983184814,
	0.945607006549835, 0.946105003356934, 0.946600973606110, 0.947094023227692,
	0.947585999965668, 0.948074996471405, 0.948561012744904, 0.949046015739441,
	0.949527978897095, 0.950007975101471, 0.950486004352570, 0.950962007045746,
	0.951435029506683, 0.951906025409698, 0.952374994754791, 0.952841997146606,
	0.953306019306183, 0.953768014907837, 0.954227983951569, 0.954685986042023,
	0.955141007900238, 0.955594003200531, 0.956044971942902, 0.956493973731995,
	0.956939995288849, 0.957385003566742, 0.957826018333435, 0.958266019821167,
	0.958702981472015, 0.959138989448547, 0.959572017192841, 0.960002005100250,
	0.960430979728699, 0.960856974124908, 0.961279988288879, 0.961701989173889,
	0.962121009826660, 0.962538003921509, 0.962952971458435, 0.963365972042084,
	0.963775992393494, 0.964183986186981, 0.964590013027191, 0.964993000030518,
	0.965394020080566, 0.965793013572693, 0.966189980506897, 0.966584026813507,
	0.966975986957550, 0.967365980148315, 0.967754006385803, 0.968138992786407,
	0.968522012233734, 0.968903005123138, 0.969281017780304, 0.969657003879547,
	0.970031023025513, 0.970403015613556, 0.970772027969360, 0.971139013767242,
	0.971503973007202, 0.971866011619568, 0.972226977348328, 0.972584009170532,
	0.972940027713776, 0.973293006420135, 0.973644018173218, 0.973993003368378,
	0.974339008331299, 0.974684000015259, 0.975024998188019, 0.975364983081818,
	0.975701987743378, 0.976037025451660, 0.976369976997375, 0.976700007915497,
	0.977028012275696, 0.977353990077972, 0.977676987648010, 0.977998971939087,
	0.978317022323608, 0.978633999824524, 0.978947997093201, 0.979260027408600,
	0.979569971561432, 0.979876995086670, 0.980181992053986, 0.980485022068024,
	0.980785012245178, 0.981082975864410, 0.981378972530365, 0.981673002243042,
	0.981963992118835, 0.982253015041351, 0.982538998126984, 0.982824027538300,
	0.983105003833771, 0.983385026454926, 0.983662009239197, 0.983937025070190,
	0.984210014343262, 0.984480023384094, 0.984749019145966, 0.985014021396637,
	0.985278010368347, 0.985539019107819, 0.985798001289368, 0.986054003238678,
	0.986307978630066, 0.986559987068176, 0.986809015274048, 0.987056970596313,
	0.987300992012024, 0.987544000148773, 0.987784028053284, 0.988022029399872,
	0.988258004188538, 0.988490998744965, 0.988722026348114, 0.988950014114380,
	0.989176988601685, 0.989400029182434, 0.989621996879578, 0.989840984344482,
	0.990058004856110, 0.990272998809814, 0.990485012531281, 0.990694999694824,
	0.990903019905090, 0.991108000278473, 0.991311013698578, 0.991510987281799,
	0.991710007190704, 0.991905987262726, 0.992098987102509, 0.992290973663330,
	0.992479979991913, 0.992666006088257, 0.992850005626678, 0.993031978607178,
	0.993211984634399, 0.993389010429382, 0.993564009666443, 0.993736982345581,
	0.993906974792480, 0.994075000286102, 0.994239985942841, 0.994404017925262,
	0.994565010070801, 0.994723021984100, 0.994879007339478, 0.995033025741577,
	0.995185017585754, 0.995334029197693, 0.995481014251709, 0.995625019073486,
	0.995766997337341, 0.995907008647919, 0.996044993400574, 0.996179997920990,
	0.996312975883484, 0.996442973613739, 0.996571004390717, 0.996697008609772,
	0.996819972991943, 0.996940970420837, 0.997060000896454, 0.997175991535187,
	0.997290015220642, 0.997402012348175, 0.997511029243469, 0.997618019580841,
	0.997722983360291, 0.997825026512146, 0.997924983501434, 0.998022973537445,
	0.998117983341217, 0.998211026191711, 0.998301982879639, 0.998390018939972,
	0.998476028442383, 0.998558998107910, 0.998640000820160, 0.998718976974487,
	0.998794972896576, 0.998870015144348, 0.998941004276276, 0.999010980129242,
	0.999077975749969, 0.999141991138458, 0.999204993247986, 0.999265015125275,
	0.999321997165680, 0.999378025531769, 0.999431014060974, 0.999481022357941,
	0.999529004096985, 0.999575018882751, 0.999619007110596, 0.999660015106201,
	0.999698996543884, 0.999734997749329, 0.999768972396851, 0.999800980091095,
	0.999831020832062, 0.999858021736145, 0.999881982803345, 0.999904990196228,
	0.999925017356873, 0.999942004680634, 0.999957978725433, 0.999970972537994,
	0.999980986118317, 0.999988973140717, 0.999994993209839, 1.000000000000000
};

// // // // // // // // // // // //
//                               //
//           FUNCTIONS           //
//                               //
// // // // // // // // // // // //

// 0x800C7840
f32 lbCommonSin(f32 angle)
{
	u16 index = ((s32) (angle * 651.8986206F)) & 0xFFF;
    f32 sin;
    
    if (index & 0x400)
    {
        sin = dLBCommonSinLookup[0x3FF - (index & 0x3FF)];
    }
    else sin = dLBCommonSinLookup[index & 0x3FF];
    
    if (index & 0x800)
    {
        return -sin;
    }
    else return sin;
}

// 0x800C78B8
f32 lbCommonCos(f32 angle)
{
    u16 index = ((s32) ((angle + F_CST_DTOR32(90.0F)) * 651.8986206F)) & 0xFFF;
    f32 cos;
    
    if (index & 0x400)
    {
        cos = dLBCommonSinLookup[0x3FF - (index & 0x3FF)];
    }
    else cos = dLBCommonSinLookup[index & 0x3FF];
    
    if (index & 0x800)
    {
        return -cos;
    }
    else return cos;
}

// 0x800C793C
f32 lbCommonTan(f32 angle)
{
    u16 index = ((s32) (angle * 651.8986206F)) & 0xFFF;
    f32 sin, cos;
    
    if (index & 0x400)
    {
        sin = dLBCommonSinLookup[0x3FF - (index & 0x3FF)];
    }
    else sin = dLBCommonSinLookup[index & 0x3FF];
    
    if (index & 0x800)
    {
        sin = -sin;
    }
    index = (index + 0x400) & 0xFFF;
    
    if (index & 0x400)
    {
        cos = dLBCommonSinLookup[0x3FF - (index & 0x3FF)];
    }
    else cos = dLBCommonSinLookup[index & 0x3FF];
    
    if (index & 0x800)
    {
        cos = -cos;
    }
    return sin / cos;
}

// 0x800C7A00
f32 lbCommonNormDist2D(Vec3f *vec)
{
	f32 magnitude;
	f32 factor;

	magnitude = sqrtf(SQUARE(vec->x) + SQUARE(vec->y));

	if (magnitude == 0.0F)
	{
		return 0.0F;
	}
	factor = 1.0F / magnitude;

	vec->x = vec->x * factor;
	vec->y = vec->y * factor;

	return magnitude;
}

// 0x800C7A84
f32 lbCommonMag2D(Vec3f *vec)
{
	return sqrtf(SQUARE(vec->x) + SQUARE(vec->y));
}

// 0x800C7AB8
Vec3f* lbCommonAdd2D(Vec3f *a, Vec3f *b)
{
	a->x = a->x + b->x;
	a->y = a->y + b->y;

	return a;
}

// 0x800C7AE0
Vec3f* lbCommonScale2D(Vec3f *vec, f32 factor)
{
	vec->x = vec->x * factor;
	vec->y = vec->y * factor;

	return vec;
}

// 0x800C7B08
Vec3f* lbCommonReflect2D(Vec3f *a, Vec3f *b)
{
	f32 negative_two_dot_product = (b->x * a->x + b->y * a->y) * -2.0F;

	a->x = a->x + b->x * negative_two_dot_product;
	a->y = a->y + b->y * negative_two_dot_product;

	return a;
}

// 0x800C7B58
f32 lbCommonSim3D(Vec3f *a, Vec3f *b)
{
	f32 magnitude_a = sqrtf(SQUARE(a->x) + SQUARE(a->y) + SQUARE(a->z));
	f32 magnitude_b = sqrtf(SQUARE(b->x) + SQUARE(b->y) + SQUARE(b->z));

	return (a->x * b->x + a->y * b->y + a->z * b->z) / (magnitude_b + magnitude_a);
}

// 0x800C7C0C
f32 lbCommonSim2D(Vec3f *a, Vec3f *b)
{
	f32 magnitude_a = sqrtf(SQUARE(a->x) + SQUARE(a->y));
	f32 magnitude_b = sqrtf(SQUARE(b->x) + SQUARE(b->y));
	
	return (a->x * b->x + a->y * b->y) / (magnitude_b + magnitude_a);
}

// 0x800C7C98
sb32 lbCommonCheckAdjustSim2D(Vec3f *a, Vec3f *b, f32 angle)
{
    f32 similarity;
    f32 orientation;
    f32 magnitude;
    
    similarity = lbCommonSim2D(b, a);

    if (similarity <= 0.0F)
    {
        if (similarity >= cosf(angle + F_CST_DTOR32(90.0F)))
        {
            orientation = b->x * a->y - b->y * a->x;
            
            orientation = (orientation < 0.0F) ? -1.0F : 1.0F;
            
            magnitude = lbCommonMag2D(a) * orientation;
            
            a->x = -b->y * magnitude;
            a->y = b->x * magnitude;
            
            return TRUE;
        }
    }
    return FALSE;
}

// 0x800C7DB4
void lbCommonMatrixTraRotScaInv
(
    Mtx *mtx,
    f32 trax,
    f32 tray,
    f32 traz,
    f32 rotx,
    f32 roty,
    f32 rotz,
    f32 scax_inv,
    f32 scay_inv,
    f32 scaz_inv,
    f32 scax,
    f32 scay,
    f32 scaz
)
{    
    u32 e1, e2;
    s32 sinx, cosx;
    s32 siny, cosy;
    s32 sinz, cosz;
    s32 scay_l, scax_l, scaz_l;
    s32 scax_inv_l, scay_inv_l, scaz_inv_l;
    u16 idx, idy, idz;

    idx = ((s32) (rotx * 651.8986206F)) & 0xFFF;
    
    sinx = gSinTable[idx & 0x7FF];
    
    if (idx & 0x800)
    {
        sinx = -sinx;
    }
    idx += 0x400;
    
    cosx = gSinTable[idx & 0x7FF];
    
    if (idx & 0x800)
    {
        cosx = -cosx;
    }
    idy = ((s32) (roty * 651.8986206F)) & 0xFFF;
    
    siny = gSinTable[idy & 0x7FF];
    
    if (idy & 0x800)
    {
        siny = -siny;
    }
    idy += 0x400;
    
    cosy = gSinTable[idy & 0x7FF];
    
    if (idy & 0x800)
    {
        cosy = -cosy;
    }
    idz = ((s32) (rotz * 651.8986206F)) & 0xFFF;
    
    sinz = gSinTable[idz & 0x7FF];
    
    if (idz & 0x800)
    {
        sinz = -sinz;
    }
    idz += 0x400;
    
    cosz = gSinTable[idz & 0x7FF];
    
    if (idz & 0x800)
    {
        cosz = -cosz;
    }
    scax_l = (scax * 256.0F);
    scay_l = (scay * 256.0F);
    scaz_l = (scaz * 256.0F);
    
    scax_inv_l = ((1.0F / scax_inv) * 256.0F);
    scay_inv_l = ((1.0F / scay_inv) * 256.0F);
    scaz_inv_l = ((1.0F / scaz_inv) * 256.0F);

    e1 = (((((cosy * cosz) >> 14) * scax_l) >> 8) * scax_inv_l) >> 8;
    e2 = (((((cosy * sinz) >> 14) * scax_l) >> 8) * scay_inv_l) >> 8;

    mtx->m[0][0] = COMBINE_INTEGRAL(e1, e2);
    mtx->m[2][0] = COMBINE_FRACTIONAL(e1, e2);
    
    e1 = (((-siny * scax_l) >> 7) * scaz_inv_l) >> 8;
    
    mtx->m[0][1] = COMBINE_INTEGRAL(e1, 0);
    mtx->m[2][1] = COMBINE_FRACTIONAL(e1, 0);
    
    e1 = ((((((((sinx * siny) >> 15) * cosz) >> 14) - ((cosx * sinz) >> 14)) * scay_l) >> 8) * scax_inv_l) >> 8;
    e2 = ((((((((sinx * siny) >> 15) * sinz) >> 14) + ((cosx * cosz) >> 14)) * scay_l) >> 8) * scay_inv_l) >> 8;

    mtx->m[0][2] = COMBINE_INTEGRAL(e1, e2);
    mtx->m[2][2] = COMBINE_FRACTIONAL(e1, e2);
    
    e1 = (((((sinx * cosy) >> 14) * scay_l) >> 8) * scaz_inv_l) >> 8;

    mtx->m[0][3] = COMBINE_INTEGRAL(e1, 0);
    mtx->m[2][3] = COMBINE_FRACTIONAL(e1, 0);

    e1 = ((((((((cosx * siny) >> 15) * cosz) >> 14) + ((sinx * sinz) >> 14)) * scaz_l) >> 8) * scax_inv_l) >> 8;
    e2 = ((((((((cosx * siny) >> 15) * sinz) >> 14) - ((sinx * cosz) >> 14)) * scaz_l) >> 8) * scay_inv_l) >> 8;
    
    mtx->m[1][0] = COMBINE_INTEGRAL(e1, e2);
    mtx->m[3][0] = COMBINE_FRACTIONAL(e1, e2);
    
    e1 = (((((cosx * cosy) >> 14) * scaz_l) >> 8) * scaz_inv_l) >> 8;

    mtx->m[1][1] = COMBINE_INTEGRAL(e1, 0);
    mtx->m[3][1] = COMBINE_FRACTIONAL(e1, 0);

    e1 = (s32) (trax * 65536.0F);
    e2 = (s32) (tray * 65536.0F);

    mtx->m[1][2] = COMBINE_INTEGRAL(e1, e2);
    mtx->m[3][2] = COMBINE_FRACTIONAL(e1, e2);

    e1 = (s32) (traz * 65536.0F);
    
    mtx->m[1][3] = COMBINE_INTEGRAL(e1, 0x10000);
    mtx->m[3][3] = COMBINE_FRACTIONAL(e1, 0);
}

// 0x800C82AC
void lbCommonMatrixRotSca(Mtx *mtx, f32 rotx, f32 roty, f32 rotz, f32 scax, f32 scay, f32 scaz)
{
    u32 e1, e2;
    s32 sinx, cosx;
    s32 siny, cosy;
    s32 sinz, cosz;
    s32 scay_l, scax_l, scaz_l;
    u16 idx, idy, idz;

    idx = ((s32) (rotx * 651.8986206F)) & 0xFFF;
    
    sinx = gSinTable[idx & 0x7FF];
    
    if (idx & 0x800)
    {
        sinx = -sinx;
    }
    idx += 0x400;
    
    cosx = gSinTable[idx & 0x7FF];
    
    if (idx & 0x800)
    {
        cosx = -cosx;
    }
    idy = ((s32) (roty * 651.8986206F)) & 0xFFF;
    
    siny = gSinTable[idy & 0x7FF];
    
    if (idy & 0x800)
    {
        siny = -siny;
    }
    idy += 0x400;
    
    cosy = gSinTable[idy & 0x7FF];
    
    if (idy & 0x800)
    {
        cosy = -cosy;
    }
    idz = ((s32) (rotz * 651.8986206F)) & 0xFFF;
    
    sinz = gSinTable[idz & 0x7FF];
    
    if (idz & 0x800)
    {
        sinz = -sinz;
    }
    idz += 0x400;
    
    cosz = gSinTable[idz & 0x7FF];
    
    if (idz & 0x800)
    {
        cosz = -cosz;
    }
    scax_l = (scax * 256.0F);
    scay_l = (scay * 256.0F);
    scaz_l = (scaz * 256.0F);

    e1 = ((((cosy * cosz) >> 14) * scax_l) >> 8);
    e2 = ((((cosy * sinz) >> 14) * scax_l) >> 8);

    mtx->m[0][0] = COMBINE_INTEGRAL(e1, e2);
    mtx->m[2][0] = COMBINE_FRACTIONAL(e1, e2);
    
    e1 = ((-siny * scax_l) >> 7);
    
    mtx->m[0][1] = COMBINE_INTEGRAL(e1, 0);
    mtx->m[2][1] = COMBINE_FRACTIONAL(e1, 0);
    
    e1 = (((((((sinx * siny) >> 15) * cosz) >> 14) - ((cosx * sinz) >> 14)) * scay_l) >> 8);
    e2 = (((((((sinx * siny) >> 15) * sinz) >> 14) + ((cosx * cosz) >> 14)) * scay_l) >> 8);

    mtx->m[0][2] = COMBINE_INTEGRAL(e1, e2);
    mtx->m[2][2] = COMBINE_FRACTIONAL(e1, e2);
    
    e1 = ((((sinx * cosy) >> 14) * scay_l) >> 8);

    mtx->m[0][3] = COMBINE_INTEGRAL(e1, 0);
    mtx->m[2][3] = COMBINE_FRACTIONAL(e1, 0);

    e1 = (((((((cosx * siny) >> 15) * cosz) >> 14) + ((sinx * sinz) >> 14)) * scaz_l) >> 8);
    e2 = (((((((cosx * siny) >> 15) * sinz) >> 14) - ((sinx * cosz) >> 14)) * scaz_l) >> 8);
    
    mtx->m[1][0] = COMBINE_INTEGRAL(e1, e2);
    mtx->m[3][0] = COMBINE_FRACTIONAL(e1, e2);
    
    e1 = ((((cosx * cosy) >> 14) * scaz_l) >> 8);

    mtx->m[1][1] = COMBINE_INTEGRAL(e1, 0);
    mtx->m[3][1] = COMBINE_FRACTIONAL(e1, 0);

    mtx->m[1][2] = COMBINE_INTEGRAL(0, 0);
    mtx->m[3][2] = COMBINE_FRACTIONAL(0, 0);
    mtx->m[1][3] = COMBINE_INTEGRAL(0, 0x10000);
    mtx->m[3][3] = COMBINE_FRACTIONAL(0, 0);
}

// 0x800C8634
void func_ovl0_800C8634(void)
{
	func_8000A5E4();
}

// 0x800C8654
alSoundEffect* lbCommonMakePositionFGM(u16 fgm, f32 pos)
{
    alSoundEffect *snd = func_80026A10_27610(fgm);
    
    if (snd != NULL)
    {
        s32 balance = ((pos / 8000.0F) * 60.0F);
        
        if (balance > 60)
        {
            balance = 60;
        }
        if (balance < -60)
        {
            balance = -60;
        }
        balance = 64 - balance;
        
        snd->balance = balance;

        func_800267F4_273F4(snd);
    }
    return snd;
}

// 0x800C86E8
DObj* lbCommonGetTreeDObjNextFromRoot(DObj *a, DObj *b)
{
    if (a->child != NULL)
    {
        a = a->child;
    }
    else if (a == b)
    {
        a = NULL;
    }
    else if (a->sib_next != NULL)
    {
        a = a->sib_next;
    }
    else while (TRUE)
    {
        if (a->parent == b)
        {
            a = NULL;

            break;
        }
        else if (a->parent->sib_next != NULL)
        {
            a = a->parent->sib_next;

            break;
        }
        else a = a->parent;
    }
    return a;
}

// 0x800C8758
void lbCommonAddDObjAnimJointAll(DObj *root_dobj, AObjEvent32 **anim_joints, f32 anim_frame)
{
    DObj *current_dobj = root_dobj;
    
    root_dobj->parent_gobj->anim_frame = anim_frame;

    while (current_dobj != NULL)
    {
        AObjEvent32 *anim_joint = *anim_joints;
        
        if (anim_joint != NULL)
        {
            gcAddDObjAnimJoint(current_dobj, anim_joint, anim_frame);
        }
        else current_dobj->anim_remain = AOBJ_ANIM_NULL;
        
        anim_joints++;
        
        current_dobj = lbCommonGetTreeDObjNextFromRoot(current_dobj, root_dobj);
    }
}

// 0x800C87F4
void lbCommonAddFighterPartsFigatree(DObj *root_dobj, void **figatrees, f32 anim_frame)
{
    DObj *current_dobj = root_dobj;
    
    root_dobj->parent_gobj->anim_frame = anim_frame;

    while (current_dobj != NULL)
    {
        void *figatree = *figatrees;
        ftParts *ft_parts = current_dobj->user_data.p;
        
        if (figatree != NULL)
        {
            gcAddDObjAnimJoint(current_dobj, figatree, anim_frame);

            ft_parts->is_have_anim = TRUE;
        }
        else
        {
            current_dobj->anim_remain = AOBJ_ANIM_NULL;

            ft_parts->is_have_anim = FALSE;
        }
        figatrees++;
        
        current_dobj = lbCommonGetTreeDObjNextFromRoot(current_dobj, root_dobj);
    }
}

// 0x800C88AC
void lbCommonAddDObjAnimAll(DObj *root_dobj, AObjEvent32 **anim_joints, AObjEvent32 ***p_matanim_joints, f32 anim_frame)
{
    DObj *current_dobj = root_dobj;
    
    root_dobj->parent_gobj->anim_frame = anim_frame;

    while (current_dobj != NULL)
    {
        if (anim_joints != NULL)
        {
            AObjEvent32 *anim_joint = *anim_joints;

            if (anim_joint != NULL)
            {
                gcAddDObjAnimJoint(current_dobj, anim_joint, anim_frame);
            }
            else current_dobj->anim_remain = AOBJ_ANIM_NULL;

            anim_joints++;
        }
        if (p_matanim_joints != NULL)
        {
            if (*p_matanim_joints != NULL)
            {
                MObj *mobj = current_dobj->mobj;
                AObjEvent32 **matanim_joints = *p_matanim_joints;

                while (mobj != NULL)
                {
                    AObjEvent32 *matanim_joint = *matanim_joints;

                    if (matanim_joint != NULL)
                    {
                        gcAddMObjMatAnimJoint(mobj, matanim_joint, anim_frame);
                    }
                    mobj = mobj->next;
                    matanim_joints++;
                }
            }
            p_matanim_joints++;
        }
        current_dobj = lbCommonGetTreeDObjNextFromRoot(current_dobj, root_dobj);
    }
}

// 0x800C89BC
void lbCommonInitDObjTriTransform(DObj *dobj, u8 tk1, u8 tk2, u8 tk3)
{
    gcAddDObjTriTransformKind(dobj, tk1, tk2, tk3);
    
    dobj->translate.vec = dOMTranslateDefault.vec;
    dobj->rotate.vec = dOMRotateDefaultRPY.vec;
    dobj->scale.vec = dOMScaleDefault.vec;
}

// 0x800C8A58
void lbCommonInitDObj(DObj *dobj, u8 tk1, u8 tk2, u8 tk3, u8 arg4)
{
    if (tk1 != nOMTransformNull)
    {
        gcAddOMMtxForDObjFixed(dobj, tk1, arg4);
    }
    if (tk2 != nOMTransformNull)
    {
        gcAddOMMtxForDObjFixed(dobj, tk2, arg4);
    }
    if (tk3 != nOMTransformNull)
    {
        gcAddOMMtxForDObjFixed(dobj, tk3, arg4);
    }
    dobj->translate.vec = dOMTranslateDefault.vec;
    dobj->rotate.vec = dOMRotateDefaultRPY.vec;
    dobj->scale.vec = dOMScaleDefault.vec;
}

// 0x800C8B28
void lbCommonSetupTreeDObjs(DObj *root_dobj, DObjDesc *dobj_desc, DObj **dobjs, u8 tk1, u8 tk2, u8 tk3)
{
    s32 i;
    DObj *current_dobj;
    s32 unused;
    s32 id;
    DObj *array_dobjs[DOBJ_ARRAY_MAX];

    for (i = 0; i < ARRAY_COUNT(array_dobjs); i++)
    {
        array_dobjs[i] = NULL;
    }
    while (dobj_desc->index != ARRAY_COUNT(array_dobjs)) 
    {
        id = dobj_desc->index & 0xFFF;

        if (id != 0)
        {
            current_dobj = array_dobjs[id] = gcAddChildForDObj(array_dobjs[id - 1], dobj_desc->display_list);
        } 
        else current_dobj = array_dobjs[0] = gcAddChildForDObj(root_dobj, dobj_desc->display_list);
        
        if (dobj_desc->index & 0xF000) 
        {
            gcDecideDObjTriTransformKind(current_dobj, tk1, tk2, tk3, dobj_desc->index & 0xF000);
        } 
        else gcAddDObjTriTransformKind(current_dobj, tk1, tk2, tk3);
        
        current_dobj->translate.vec.f = dobj_desc->translate;
        current_dobj->rotate.vec.f = dobj_desc->rotate;
        current_dobj->scale.vec.f = dobj_desc->scale;

        if (dobjs != NULL) 
        {
            *dobjs++ = current_dobj;
        }
        dobj_desc++;
    }
}

// 0x800C8CB8
void lbCommonAddMObjForFighterPartsDObj
(
    DObj *dobj,
    MObjSub **mobjsubs,
    AObjEvent32 **costume_matanim_joints,
    AObjEvent32 **main_matanim_joints,
    f32 anim_frame
)
{
    if (mobjsubs != NULL)
    {
        MObjSub *mobjsub = *mobjsubs;

        while (mobjsub != NULL)
        {
            MObj *mobj = gcAddMObjForDObj(dobj, mobjsub);

            if (costume_matanim_joints != NULL)
            {
                AObjEvent32 *costume_matanim_joint = *costume_matanim_joints;

                if (costume_matanim_joint != NULL)
                {
                    gcAddMObjMatAnimJoint(mobj, costume_matanim_joint, anim_frame);
                    gcParseMObjMatAnimJoint(mobj);
                    gcPlayMObjMatAnim(mobj);
                    gcRemoveAObjFromMObj(mobj);
                }
                costume_matanim_joints++;
            }
            if (main_matanim_joints != NULL)
            {
                AObjEvent32 *main_matanim_joint = *main_matanim_joints;

                if (main_matanim_joint != NULL)
                {
                    gcAddMObjMatAnimJoint(mobj, main_matanim_joint, 0.0F);
                    gcParseMObjMatAnimJoint(mobj);
                    gcPlayMObjMatAnim(mobj);
                }
                main_matanim_joints++;
            }
            mobjsubs++;
            mobjsub = *mobjsubs;
        }
    }
}

// 0x800C8DB4
void lbCommonSetupFighterPartsDObjs
(
    DObj *root_dobj,
    ftCommonPartContainer *commonparts_container,
    s32 detail_current,
    DObj **dobjs,
    u32 *setup_parts,
    u8 tk1,
    u8 tk2,
    u8 tk3,
    f32 anim_frame,
    u8 arg9
)
{
    s32 id;
    s32 i;
    u32 flags0;
    u32 flags1;
    u32 current_flags;
    DObj *array_dobjs[DOBJ_ARRAY_MAX];
    s32 detail_id;
    DObjDesc *dobj_desc;
    DObj *current_dobj;

    dobj_desc = commonparts_container->commonparts[detail_current - 1].dobj_desc;

    flags0 = setup_parts[0], flags1 = setup_parts[1];

    for (i = 0; i < ARRAY_COUNT(array_dobjs); i++)
    {
        array_dobjs[i] = NULL;
    }
    for (i = 0; ((flags0 != 0) || (flags1 != 0)) && (dobj_desc->index != ARRAY_COUNT(array_dobjs)); i++)
    {
        current_flags = (i < GS_BITCOUNT(u32)) ? flags0 : flags1;

        if (current_flags & (1 << 31))
        {
            id = dobj_desc->index & 0xFFF;
            
            if
            (
                (detail_current == nFTPartsDetailHigh) ||
                (commonparts_container->commonparts[nFTPartsDetailLow - nFTPartsDetailStart].dobj_desc[i].display_list == NULL)
            )
            {
                detail_id = 0;
            }
            else detail_id = 1;

            if (id != 0)
            {
                current_dobj = array_dobjs[id] = gcAddChildForDObj
                (
                    array_dobjs[id - 1],
                    commonparts_container->commonparts[detail_id].dobj_desc[i].display_list
                );
            }
            else current_dobj = array_dobjs[0] = gcAddChildForDObj
            (
                root_dobj,
                commonparts_container->commonparts[detail_id].dobj_desc[i].display_list
            );
            if (dobj_desc->index & 0x8000)
            {
                gcDecideDObjTriTransformKind(current_dobj, tk1, tk2, tk3, 0x8000);
            }
            else lbCommonInitDObj(current_dobj, tk1, tk2, tk3, arg9);

            current_dobj->translate.vec.f = dobj_desc->translate;
            current_dobj->rotate.vec.f = dobj_desc->rotate;
            current_dobj->scale.vec.f = dobj_desc->scale;

            lbCommonAddMObjForFighterPartsDObj
            (
                current_dobj,
                (commonparts_container->commonparts[detail_id].p_mobjsubs != NULL) ?
                commonparts_container->commonparts[detail_id].p_mobjsubs[i] : NULL,
                (commonparts_container->commonparts[detail_id].p_costume_matanim_joints != NULL) ?
                commonparts_container->commonparts[detail_id].p_costume_matanim_joints[i] : NULL,
                NULL,
                anim_frame
            );
            if (dobjs != NULL)
            {
                *dobjs = current_dobj;
            }
        }
        dobjs++;
        dobj_desc++;

        if (i < GS_BITCOUNT(u32))
        {
            flags0 <<= 1;
        }
        else flags1 <<= 1;
    }
}

// 0x800C9050
void lbCommonSetupCustomTreeDObjsWithMObj
(
    DObj *root_dobj,
    DObjDesc *dobj_desc,
    MObjSub ***p_mobjsubs,
    DObj **dobjs,
    u8 tk1,
    u8 tk2,
    u8 tk3
)
{
    s32 i;
    DObj *dobj;
    s32 id;
    DObj *array_dobjs[DOBJ_ARRAY_MAX];

    for (i = 0; i < ARRAY_COUNT(array_dobjs); i++)
    {
        array_dobjs[i] = NULL;
    }
    while (dobj_desc->index != ARRAY_COUNT(array_dobjs)) 
    {
        id = dobj_desc->index & 0xFFF;

        if (id != 0)
        {
            dobj = array_dobjs[id] = gcAddChildForDObj(array_dobjs[id - 1], dobj_desc->display_list);
        } 
        else dobj = array_dobjs[0] = gcAddChildForDObj(root_dobj, dobj_desc->display_list);
        
        if (dobj_desc->index & 0x8000) 
        {
            gcDecideDObjTriTransformKind(dobj, tk1, tk2, tk3, 0x8000);
        } 
        else gcAddDObjTriTransformKind(dobj, tk1, tk2, tk3);
        
        dobj->translate.vec.f = dobj_desc->translate;
        dobj->rotate.vec.f = dobj_desc->rotate;
        dobj->scale.vec.f = dobj_desc->scale;

        if (p_mobjsubs != NULL)
        {
            if (*p_mobjsubs != NULL)
            {
                MObjSub **mobjsubs = *p_mobjsubs;
                MObjSub *mobjsub = *mobjsubs;

                while (mobjsub != NULL)
                {
                    gcAddMObjForDObj(dobj, mobjsub);

                    mobjsubs++;

                    mobjsub = *mobjsubs;
                }
            }
            p_mobjsubs++;
        }
        if (dobjs != NULL)
        {
            *dobjs++ = dobj;
        }
        dobj_desc++;
    }
}

// 0x800C9228
void lbCommonAddMObjForTreeDObjs(DObj *root_dobj, MObjSub ***p_mobjsubs)
{
    DObj *current_dobj = root_dobj;
    
    while (current_dobj != NULL)
    {
        if (p_mobjsubs != NULL)
        {
            if (*p_mobjsubs != NULL)
            {
                MObjSub **mobjsubs = *p_mobjsubs;
                MObjSub *mobjsub = *mobjsubs;
                    
                while (mobjsub != NULL)
                {
                    gcAddMObjForDObj(current_dobj, mobjsub);
                        
                    mobjsubs++;
                    mobjsub = *mobjsubs;
                }
            }
            p_mobjsubs++;
        }
        current_dobj = lbCommonGetTreeDObjNextFromRoot(current_dobj, root_dobj);
    }
}

// 0x800C92C8
void lbCommonPlayTreeDObjsAnim(DObj *root_dobj)
{
    DObj *current_dobj = root_dobj;
    
    while (current_dobj != NULL)
    {
        gcPlayDObjAnim(current_dobj);
        current_dobj = lbCommonGetTreeDObjNextFromRoot(current_dobj, root_dobj);
    }
}

// 0x800C9314
void lbCommonSetDObjTransformsForTreeDObjs(DObj *root_dobj, DObjDesc *dobj_desc)
{
    DObj *current_dobj = root_dobj;
    
    while ((current_dobj != NULL) && (dobj_desc->index != DOBJ_ARRAY_MAX))
    {
        current_dobj->translate.vec.f = dobj_desc->translate;
        current_dobj->rotate.vec.f = dobj_desc->rotate;
        current_dobj->scale.vec.f = dobj_desc->scale;

        dobj_desc++;
        
        current_dobj = lbCommonGetTreeDObjNextFromRoot(current_dobj, root_dobj);
    }
}

// 0x800C93D4
void lbCommonInsertTreeDObjChild(DObj *root_dobj, void *dvar)
{
	DObj *dobj = gcAddDObjForGObj(root_dobj->parent_gobj, dvar);

	dobj->sib_prev->sib_next = NULL;
	dobj->sib_prev = NULL;
	root_dobj->child->parent = dobj;
	dobj->child = root_dobj->child;
	root_dobj->child = dobj;
	dobj->parent = root_dobj;
}

// 0x800C9424
void lbCommonEjectTreeDObj(DObj *dobj)
{
    DObj *child_dobj = dobj->child;
    DObj *parent_dobj = dobj->parent;

    dobj->child = NULL;
    
    gcEjectDObj(dobj);
    
    if (parent_dobj == DOBJ_PARENT_NULL)
    {
        child_dobj->parent_gobj->obj = child_dobj;
        child_dobj->parent_gobj->obj_kind = nOMObjCommonAppendDObj;
    } 
    else parent_dobj->child = child_dobj;
    
    child_dobj->parent = parent_dobj;
}

// 0x800C9488
void lbCommonPlayTranslateScaledDObjAnim(DObj *dobj, Vec3f *scale)
{
    f32 interp;

    if (dobj->anim_remain != AOBJ_ANIM_NULL)
    {
        AObj *aobj = dobj->aobj;

        while (aobj != NULL)
        {
            if (aobj->kind != nOMObjAnimKindNone)
            {
                if (dobj->anim_remain != AOBJ_ANIM_END)
                {
                    aobj->length += dobj->anim_speed;
                }
                if (!(dobj->parent_gobj->flags & GOBJ_FLAG_NOANIM))
                {
                    switch (aobj->track)
                    {
                    case nOMObjAnimTrackRotX:
                        dobj->rotate.vec.f.x = gcGetAObjValue(aobj);
                        break;

                    case nOMObjAnimTrackRotY:
                        dobj->rotate.vec.f.y = gcGetAObjValue(aobj);
                        break;

                    case nOMObjAnimTrackRotZ:
                        dobj->rotate.vec.f.z = gcGetAObjValue(aobj);
                        break;

                    case nOMObjAnimTrackTraI:
                        interp = gcGetAObjValue(aobj);

                        if (interp < 0.0F)
                        {
                            interp = 0.0F;
                        }
                        else if (interp > 1.0F)
                        {
                            interp = 1.0F;
                        }
                        hal_interpolation_cubic(&dobj->translate.vec.f, aobj->interpolate, interp);

                        dobj->translate.vec.f.x *= scale->x;
                        dobj->translate.vec.f.y *= scale->y;
                        dobj->translate.vec.f.z *= scale->z;
                        break;

                    case nOMObjAnimTrackTraX:
                        dobj->translate.vec.f.x = gcGetAObjValue(aobj) * scale->x;
                        break;

                    case nOMObjAnimTrackTraY:
                        dobj->translate.vec.f.y = gcGetAObjValue(aobj) * scale->y;
                        break;

                    case nOMObjAnimTrackTraZ:
                        dobj->translate.vec.f.z = gcGetAObjValue(aobj) * scale->z;
                        break;

                    case nOMObjAnimTrackScaX:
                        dobj->scale.vec.f.x = gcGetAObjValue(aobj);
                        break;

                    case nOMObjAnimTrackScaY:
                        dobj->scale.vec.f.y = gcGetAObjValue(aobj);
                        break;

                    case nOMObjAnimTrackScaZ:
                        dobj->scale.vec.f.z = gcGetAObjValue(aobj);
                        break;
                    }
                }
            }
            aobj = aobj->next;
        }
        if (dobj->anim_remain == AOBJ_ANIM_END)
        {
            dobj->anim_remain = AOBJ_ANIM_NULL;
        }
    }
}

// 0x800C96DC
void func_ovl0_800C96DC(Mtx *mtx, DObj *dobj, Gfx **dls)
{
    return;
}

// 0x800C96EC
sb32 func_ovl0_800C96EC(Mtx *mtx, DObj *dobj, Gfx **dls)
{
	func_ovl0_800C96DC(mtx, dobj, 0);

	return 0;
}

// 0x800C9714
sb32 func_ovl0_800C9714(Mtx *mtx, DObj *dobj, Gfx **dls)
{
	func_ovl0_800C96DC(mtx, dobj, 1);

	return 0;
}

// 0x800C973C
sb32 lbCommonFighterPartsProcMatrix(Mtx *mtx, DObj *dobj, Gfx **dls)
{
    ub32 flag = ftGetStruct(dobj->parent_gobj)->is_use_animlocks;
    ftParts *ft_parts = ftGetParts(dobj);
    
    if (!(flag))
    {
        if (ft_parts->transform_update_mode != 0)
        {
            syMatrixF2LFixedW(&ft_parts->unk_dobjtrans_0x10, mtx);
        }
        else
        {
            if ((dobj->scale.vec.f.x != 1.0F) || (dobj->scale.vec.f.y != 1.0F) || (dobj->scale.vec.f.z != 1.0F))
            {
                syMatrixTraRotRpyRSca
                (
                    mtx,
                    dobj->translate.vec.f.x,
                    dobj->translate.vec.f.y,
                    dobj->translate.vec.f.z,
                    dobj->rotate.vec.f.x,
                    dobj->rotate.vec.f.y,
                    dobj->rotate.vec.f.z,
                    dobj->scale.vec.f.x,
                    dobj->scale.vec.f.y,
                    dobj->scale.vec.f.z
                );
            }
            else syMatrixTraRotRpyR
            (
                mtx,
                dobj->translate.vec.f.x,
                dobj->translate.vec.f.y,
                dobj->translate.vec.f.z,
                dobj->rotate.vec.f.x,
                dobj->rotate.vec.f.y,
                dobj->rotate.vec.f.z
            );
        }
    }
    else
    {
        if (ft_parts->transform_update_mode != 0)
        {
            syMatrixF2LFixedW(&ft_parts->unk_dobjtrans_0x10, mtx);
        }
        else
        {
            ft_parts->vec_scale.x = dobj->scale.vec.f.x * D_800D62D0.x;
            ft_parts->vec_scale.y = dobj->scale.vec.f.y * D_800D62D0.y;
            ft_parts->vec_scale.z = dobj->scale.vec.f.z * D_800D62D0.z;

            lbCommonMatrixTraRotScaInv
            (
                mtx,
                dobj->translate.vec.f.x,
                dobj->translate.vec.f.y,
                dobj->translate.vec.f.z,
                dobj->rotate.vec.f.x,
                dobj->rotate.vec.f.y,
                dobj->rotate.vec.f.z,
                D_800D62D0.x,
                D_800D62D0.y,
                D_800D62D0.z,
                ft_parts->vec_scale.x,
                ft_parts->vec_scale.y,
                ft_parts->vec_scale.z
            );
        }
        D_800D62D0 = ft_parts->vec_scale;
    }
    return 0;
}

// 0x800C994C
sb32 func_ovl0_800C994C(Mtx *mtx, DObj *dobj, Gfx **dls)
{
    s32 unused;
    DObj *attach_dobj = dobj->user_data.p;
    ftParts *ft_parts = attach_dobj->user_data.p;
    Mtx44f f;
    
    func_ovl2_800EDBA4(attach_dobj);
    gmCollisionCopyMatrix(f, ft_parts->mtx_translate);
    gODScaleX = sqrtf(SQUARE(f[0][0]) + SQUARE(f[0][1]) + SQUARE(f[0][2]));
    syMatrixF2LFixedW(&f, mtx);
    
    return 0;
}

// 0x800C99CC
sb32 func_ovl0_800C99CC(Mtx *mtx, DObj *dobj, Gfx **dls)
{
    s32 unused[2];
    DObj *attach_dobj = dobj->user_data.p;
    
    // 0x800D5CA0
    Vec3f translate_default = { 0.0F, 0.0F, 0.0F };

    gmCollisionGetFighterPartsWorldPosition(attach_dobj, &translate_default);
    
    syMatrixTranslate(mtx, translate_default.x, translate_default.y, translate_default.z);
    
    return 0;
}

// 0x800C9A38
void func_ovl0_800C9A38(Mtx44f mtx, DObj *dobj)
{
    ftParts *ft_parts = ftGetParts(dobj);
    ftStruct *fp = ftGetStruct(dobj->parent_gobj);
    Mtx44f *p;
    f32 scale;
    DObj *parent_dobj;
    Mtx44f f;
    
    if ((fp->is_use_animlocks) || (dobj->parent == DOBJ_PARENT_NULL))
    {
        func_ovl2_800EDBA4(dobj);

        p = &ft_parts->mtx_translate;
        
        scale = sqrtf(SQUARE((*p)[0][0]) + SQUARE((*p)[0][1]) + SQUARE((*p)[0][2]));

        if (scale != 0.0F)
        {
            scale = 1.0F / scale;
        }
        mtx[0][0] = (*p)[0][0] * scale;
        mtx[0][1] = (*p)[0][1] * scale;
        mtx[0][2] = (*p)[0][2] * scale;
        
        scale = sqrtf(SQUARE((*p)[1][0]) + SQUARE((*p)[1][1]) + SQUARE((*p)[1][2]));

        if (scale != 0.0F)
        {
            scale = 1.0F / scale;
        }
        mtx[1][0] = (*p)[1][0] * scale;
        mtx[1][1] = (*p)[1][1] * scale;
        mtx[1][2] = (*p)[1][2] * scale;
        
        scale = sqrtf(SQUARE((*p)[2][0]) + SQUARE((*p)[2][1]) + SQUARE((*p)[2][2]));

        if (scale != 0.0F)
        {
            scale = 1.0F / scale;
        }
        mtx[2][0] = (*p)[2][0] * scale;
        mtx[2][1] = (*p)[2][1] * scale;
        mtx[2][2] = (*p)[2][2] * scale;
        
        mtx[3][0] = (*p)[3][0];
        mtx[3][1] = (*p)[3][1];
        mtx[3][2] = (*p)[3][2];
    }
    else
    {
        parent_dobj = dobj->parent;
        
        gmCollisionTransformMatrixAll(dobj, ft_parts, ft_parts->unk_dobjtrans_0x10);

        p = &ft_parts->unk_dobjtrans_0x10;

        scale = sqrtf(SQUARE((*p)[0][0]) + SQUARE((*p)[0][1]) + SQUARE((*p)[0][2]));

        if (scale != 0.0F)
        {
            scale = 1.0F / scale;
        }
        f[0][0] = (*p)[0][0] * scale;
        f[0][1] = (*p)[0][1] * scale;
        f[0][2] = (*p)[0][2] * scale;

        scale = sqrtf(SQUARE((*p)[1][0]) + SQUARE((*p)[1][1]) + SQUARE((*p)[1][2]));

        if (scale != 0.0F)
        {
            scale = 1.0F / scale;
        }
        f[1][0] = (*p)[1][0] * scale;
        f[1][1] = (*p)[1][1] * scale;
        f[1][2] = (*p)[1][2] * scale;

        scale = sqrtf(SQUARE((*p)[2][0]) + SQUARE((*p)[2][1]) + SQUARE((*p)[2][2]));

        if (scale != 0.0F)
        {
            scale = 1.0F / scale;
        }
        f[2][0] = (*p)[2][0] * scale;
        f[2][1] = (*p)[2][1] * scale;
        f[2][2] = (*p)[2][2] * scale;

        f[3][0] = (*p)[3][0];
        f[3][1] = (*p)[3][1];
        f[3][2] = (*p)[3][2];

        func_ovl2_800EDBA4(parent_dobj);

        p = &ftGetParts(parent_dobj)->mtx_translate;

        scale = sqrtf(SQUARE((*p)[0][0]) + SQUARE((*p)[0][1]) + SQUARE((*p)[0][2]));

        if (scale != 0.0F)
        {
            scale = 1.0F / scale;
        }
        f[0][0] *= scale;
        f[1][0] *= scale;
        f[2][0] *= scale;

        scale = sqrtf(SQUARE((*p)[1][0]) + SQUARE((*p)[1][1]) + SQUARE((*p)[1][2]));

        if (scale != 0.0F)
        {
            scale = 1.0F / scale;
        }
        f[0][1] *= scale;
        f[1][1] *= scale;
        f[2][1] *= scale;

        scale = sqrtf(SQUARE((*p)[2][0]) + SQUARE((*p)[2][1]) + SQUARE((*p)[2][2]));

        if (scale != 0.0F)
        {
            scale = 1.0F / scale;
        }
        f[0][2] *= scale;
        f[1][2] *= scale;
        f[2][2] *= scale;

        func_ovl2_800ED490(mtx, *p, f);
    }
}

// 0x800C9F30
sb32 func_ovl0_800C9F30(Mtx *mtx, DObj *dobj, Gfx **dls)
{
    Mtx44f f;

    func_ovl0_800C9A38(f, dobj->user_data.p);
    syMatrixF2LFixedW(&f, mtx);
    
    return 0;
}

// 0x800C9F70
sb32 func_ovl0_800C9F70(Mtx *mtx, DObj *dobj, Gfx **dls)
{
    DObj *attach_dobj = dobj->user_data.p;
    ftStruct *fp = ftGetStruct(attach_dobj->parent_gobj);
    Mtx44f f;
    
    func_ovl0_800C9A38(f, attach_dobj);
    
    if (fp->shuffle_timer != 0)
    {
        f[3][0] += dFTRenderMainShufflePositions[fp->is_shuffle_electric][fp->shuffle_frame_index].x;
        f[3][1] += dFTRenderMainShufflePositions[fp->is_shuffle_electric][fp->shuffle_frame_index].y;
    }
    syMatrixF2LFixedW(&f, mtx);
    
    return 0;
}

// 0x800CA024
sb32 func_ovl0_800CA024(Mtx *mtx, DObj *dobj, Gfx **dls)
{
    s32 e1, e2;

    e1 = FTOFIX32(dobj->scale.vec.f.x);
    e2 = 0;

    mtx->m[0][0] = (e1 & 0xffff0000) | ((e2 >> 16) & 0xffff);
    mtx->m[2][0] = ((e1 << 16) & 0xffff0000) | (e2 & 0xffff);

    mtx->m[0][1] = 0;
    mtx->m[2][1] = 0;
    
    e1 = 0;
    e2 = FTOFIX32(dobj->scale.vec.f.y);
    
    mtx->m[0][2] = (e1 & 0xffff0000) | ((e2 >> 16) & 0xffff);
    mtx->m[2][2] = ((e1 << 16) & 0xffff0000) | (e2 & 0xffff);

    mtx->m[0][3] = 0;
    mtx->m[2][3] = 0;
    
    mtx->m[1][0] = 0;
    mtx->m[3][0] = 0;
    
    e1 = FTOFIX32(dobj->scale.vec.f.z);
    e2 = 0;

    mtx->m[1][1] = (e1 & 0xffff0000) | ((e2 >> 16) & 0xffff);
    mtx->m[3][1] = ((e1 << 16) & 0xffff0000) | (e2 & 0xffff);  
    
    e1 = FTOFIX32(dobj->translate.vec.f.x);
    e2 = FTOFIX32(dobj->translate.vec.f.y);
    
    mtx->m[1][2] = (e1 & 0xffff0000) | ((e2 >> 16) & 0xffff);
    mtx->m[3][2] = ((e1 << 16) & 0xffff0000) | (e2 & 0xffff);
    
    e1 = FTOFIX32(dobj->translate.vec.f.z);
    e2 = 0x10000;

    mtx->m[1][3] = (e1 & 0xffff0000) | ((e2 >> 16) & 0xffff);
    mtx->m[3][3] = ((e1 << 16) & 0xffff0000) | (e2 & 0xffff);
    
    return 0;
}

// 0x800CA144
sb32 lbCommonRotScaProcMatrix(Mtx *mtx, DObj *dobj, Gfx **dls)
{
    lbCommonMatrixRotSca
    (
        mtx,
        dobj->rotate.vec.f.x,
        dobj->rotate.vec.f.y,
        dobj->rotate.vec.f.z,
        dobj->scale.vec.f.x,
        dobj->scale.vec.f.y,
        dobj->scale.vec.f.z
    );
    return 0;
}

// 0x800CA194
sb32 func_ovl0_800CA194(Mtx *mtx, DObj *dobj, Gfx **dls)
{
    s32 unused;
    int e1, e2;
    int *ai, *af;
    f32 sinz, cosz;
    Gfx *dl;

    dl = dls[0];

    ai = (int*)&mtx->m[0][0];
    af = (int*)&mtx->m[2][0];
    
    sinz = __sinf(dobj->rotate.vec.f.z);
    cosz = __cosf(dobj->rotate.vec.f.z);

    e1 = FTOFIX32(gODMatrixPerspF[0][0] * cosz + gODMatrixPerspF[1][0] * sinz);
    e2 = FTOFIX32(gODMatrixPerspF[0][1] * cosz + gODMatrixPerspF[1][1] * sinz);

    *(ai++) = (e1 & 0xffff0000) | ((e2 >> 16) & 0xffff);
    *(af++) = ((e1 << 16) & 0xffff0000) | (e2 & 0xffff);

    e1 = FTOFIX32(gODMatrixPerspF[0][2] * cosz + gODMatrixPerspF[1][2] * sinz);
    e2 = FTOFIX32(gODMatrixPerspF[0][3] * cosz + gODMatrixPerspF[1][3] * sinz);

    *(ai++) = (e1 & 0xffff0000) | ((e2 >> 16) & 0xffff);
    *(af++) = ((e1 << 16) & 0xffff0000) | (e2 & 0xffff);

    e1 = FTOFIX32(gODMatrixPerspF[0][0] * -sinz + gODMatrixPerspF[1][0] * cosz);
    e2 = FTOFIX32(gODMatrixPerspF[0][1] * -sinz + gODMatrixPerspF[1][1] * cosz);

    *(ai++) = (e1 & 0xffff0000) | ((e2 >> 16) & 0xffff);
    *(af++) = ((e1 << 16) & 0xffff0000) | (e2 & 0xffff);

    e1 = FTOFIX32(gODMatrixPerspF[0][2] * -sinz + gODMatrixPerspF[1][2] * cosz);
    e2 = FTOFIX32(gODMatrixPerspF[0][3] * -sinz + gODMatrixPerspF[1][3] * cosz);

    *(ai++) = (e1 & 0xffff0000) | ((e2 >> 16) & 0xffff);
    *(af++) = ((e1 << 16) & 0xffff0000) | (e2 & 0xffff);

    e1 = FTOFIX32(gODMatrixPerspF[2][0]);
    e2 = FTOFIX32(gODMatrixPerspF[2][1]);
    
    *(ai++) = (e1 & 0xffff0000) | ((e2 >> 16) & 0xffff);
    *(af++) = ((e1 << 16) & 0xffff0000) | (e2 & 0xffff);
    
    e1 = FTOFIX32(gODMatrixPerspF[2][2]);
    e2 = FTOFIX32(gODMatrixPerspF[2][3]);
    
    *(ai++) = (e1 & 0xffff0000) | ((e2 >> 16) & 0xffff);
    *(af++) = ((e1 << 16) & 0xffff0000) | (e2 & 0xffff);
    
    gSPMvpRecalc(dl++);
    
    gMoveWd(dl++, G_MW_MATRIX, G_MWO_MATRIX_XX_XY_I, mtx->m[0][0]);\
    gMoveWd(dl++, G_MW_MATRIX, G_MWO_MATRIX_XZ_XW_I, mtx->m[0][1]);\
    gMoveWd(dl++, G_MW_MATRIX, G_MWO_MATRIX_YX_YY_I, mtx->m[0][2]);\
    gMoveWd(dl++, G_MW_MATRIX, G_MWO_MATRIX_YZ_YW_I, mtx->m[0][3]);\
    gMoveWd(dl++, G_MW_MATRIX, G_MWO_MATRIX_ZX_ZY_I, mtx->m[1][0]);\
    gMoveWd(dl++, G_MW_MATRIX, G_MWO_MATRIX_ZZ_ZW_I, mtx->m[1][1]);\
    gMoveWd(dl++, G_MW_MATRIX, G_MWO_MATRIX_XX_XY_F, mtx->m[2][0]);\
    gMoveWd(dl++, G_MW_MATRIX, G_MWO_MATRIX_XZ_XW_F, mtx->m[2][1]);\
    gMoveWd(dl++, G_MW_MATRIX, G_MWO_MATRIX_YX_YY_F, mtx->m[2][2]);\
    gMoveWd(dl++, G_MW_MATRIX, G_MWO_MATRIX_YZ_YW_F, mtx->m[2][3]);\
    gMoveWd(dl++, G_MW_MATRIX, G_MWO_MATRIX_ZX_ZY_F, mtx->m[3][0]);\
    gMoveWd(dl++, G_MW_MATRIX, G_MWO_MATRIX_ZZ_ZW_F, mtx->m[3][1]);\
    
    dls[0] = dl;
    
    return 1;
}

// 0x800CA5C8
sb32 func_ovl0_800CA5C8(Mtx *mtx, DObj *dobj, Gfx **dls)
{
    s32 unused;
    int e1, e2;
    int *ai, *af;
    f32 sinx, siny;
    f32 cosx, cosy;
    Gfx *dl;

    dl = dls[0];

    ai = (int*)&mtx->m[0][0];
    af = (int*)&mtx->m[2][0];
    
    sinx = __sinf(dobj->rotate.vec.f.x);
    cosx = __cosf(dobj->rotate.vec.f.x);
    
    siny = __sinf(dobj->rotate.vec.f.y);
    cosy = __cosf(dobj->rotate.vec.f.y);

    e1 = FTOFIX32(gODMatrixPerspF[0][0] * cosy + gODMatrixPerspF[2][0] * -siny);
    e2 = FTOFIX32(gODMatrixPerspF[0][1] * cosy + gODMatrixPerspF[2][1] * -siny);

    *(ai++) = (e1 & 0xffff0000) | ((e2 >> 16) & 0xffff);
    *(af++) = ((e1 << 16) & 0xffff0000) | (e2 & 0xffff);

    e1 = FTOFIX32(gODMatrixPerspF[0][2] * cosy + gODMatrixPerspF[2][2] * -siny);
    e2 = FTOFIX32(gODMatrixPerspF[0][3] * cosy + gODMatrixPerspF[2][3] * -siny);

    *(ai++) = (e1 & 0xffff0000) | ((e2 >> 16) & 0xffff);
    *(af++) = ((e1 << 16) & 0xffff0000) | (e2 & 0xffff);

    e1 = FTOFIX32(gODMatrixPerspF[0][0] * sinx * siny + gODMatrixPerspF[1][0] * cosx + gODMatrixPerspF[2][0] * sinx * cosy);
    e2 = FTOFIX32(gODMatrixPerspF[0][1] * sinx * siny + gODMatrixPerspF[1][1] * cosx + gODMatrixPerspF[2][1] * sinx * cosy);

    *(ai++) = (e1 & 0xffff0000) | ((e2 >> 16) & 0xffff);
    *(af++) = ((e1 << 16) & 0xffff0000) | (e2 & 0xffff);

    e1 = FTOFIX32(gODMatrixPerspF[0][2] * sinx * siny + gODMatrixPerspF[1][2] * cosx + gODMatrixPerspF[2][2] * sinx * cosy);
    e2 = FTOFIX32(gODMatrixPerspF[0][3] * sinx * siny + gODMatrixPerspF[1][3] * cosx + gODMatrixPerspF[2][3] * sinx * cosy);

    *(ai++) = (e1 & 0xffff0000) | ((e2 >> 16) & 0xffff);
    *(af++) = ((e1 << 16) & 0xffff0000) | (e2 & 0xffff);

    e1 = FTOFIX32(gODMatrixPerspF[0][0] * cosx * siny + gODMatrixPerspF[1][0] * -sinx + gODMatrixPerspF[2][0] * cosx * cosy);
    e2 = FTOFIX32(gODMatrixPerspF[0][1] * cosx * siny + gODMatrixPerspF[1][1] * -sinx + gODMatrixPerspF[2][1] * cosx * cosy);

    *(ai++) = (e1 & 0xffff0000) | ((e2 >> 16) & 0xffff);
    *(af++) = ((e1 << 16) & 0xffff0000) | (e2 & 0xffff);

    e1 = FTOFIX32(gODMatrixPerspF[0][2] * cosx * siny + gODMatrixPerspF[1][2] * -sinx + gODMatrixPerspF[2][2] * cosx * cosy);
    e2 = FTOFIX32(gODMatrixPerspF[0][3] * cosx * siny + gODMatrixPerspF[1][3] * -sinx + gODMatrixPerspF[2][3] * cosx * cosy);

    *(ai++) = (e1 & 0xffff0000) | ((e2 >> 16) & 0xffff);
    *(af++) = ((e1 << 16) & 0xffff0000) | (e2 & 0xffff);
    
    gSPMvpRecalc(dl++);
    
    gMoveWd(dl++, G_MW_MATRIX, G_MWO_MATRIX_XX_XY_I, mtx->m[0][0]);\
    gMoveWd(dl++, G_MW_MATRIX, G_MWO_MATRIX_XZ_XW_I, mtx->m[0][1]);\
    gMoveWd(dl++, G_MW_MATRIX, G_MWO_MATRIX_YX_YY_I, mtx->m[0][2]);\
    gMoveWd(dl++, G_MW_MATRIX, G_MWO_MATRIX_YZ_YW_I, mtx->m[0][3]);\
    gMoveWd(dl++, G_MW_MATRIX, G_MWO_MATRIX_ZX_ZY_I, mtx->m[1][0]);\
    gMoveWd(dl++, G_MW_MATRIX, G_MWO_MATRIX_ZZ_ZW_I, mtx->m[1][1]);\
    gMoveWd(dl++, G_MW_MATRIX, G_MWO_MATRIX_XX_XY_F, mtx->m[2][0]);\
    gMoveWd(dl++, G_MW_MATRIX, G_MWO_MATRIX_XZ_XW_F, mtx->m[2][1]);\
    gMoveWd(dl++, G_MW_MATRIX, G_MWO_MATRIX_YX_YY_F, mtx->m[2][2]);\
    gMoveWd(dl++, G_MW_MATRIX, G_MWO_MATRIX_YZ_YW_F, mtx->m[2][3]);\
    gMoveWd(dl++, G_MW_MATRIX, G_MWO_MATRIX_ZX_ZY_F, mtx->m[3][0]);\
    gMoveWd(dl++, G_MW_MATRIX, G_MWO_MATRIX_ZZ_ZW_F, mtx->m[3][1]);\
    
    dls[0] = dl;
    
    return 1;
}

// 0x800CAB48
sb32 func_ovl0_800CAB48(Mtx *mtx, DObj *dobj, Gfx **dls)
{
    f32 scaley;
    int e1, e2;
    int *ai, *af;
    f32 sinx, siny;
    f32 cosx, cosy;
    f32 *p;
    f32 scalex;
    Gfx *dl;

    dl = dls[0];

    ai = (int*)&mtx->m[0][0];
    af = (int*)&mtx->m[2][0];

    sinx = __sinf(dobj->rotate.vec.f.x);
    cosx = __cosf(dobj->rotate.vec.f.x);

    p = &dobj->scale.vec.f.x;
    
    siny = __sinf(dobj->rotate.vec.f.y);
    cosy = __cosf(dobj->rotate.vec.f.y);

    scaley = (dobj->scale.vec.f.y * gODScaleX);
    scalex = gODScaleX *= *p;

    e1 = FTOFIX32((gODMatrixPerspF[0][0] * cosy + gODMatrixPerspF[2][0] * -siny) * scalex);
    e2 = FTOFIX32((gODMatrixPerspF[0][1] * cosy + gODMatrixPerspF[2][1] * -siny) * scalex);

    *(ai++) = (e1 & 0xffff0000) | ((e2 >> 16) & 0xffff);
    *(af++) = ((e1 << 16) & 0xffff0000) | (e2 & 0xffff);

    e1 = FTOFIX32((gODMatrixPerspF[0][2] * cosy + gODMatrixPerspF[2][2] * -siny) * scalex);
    e2 = FTOFIX32((gODMatrixPerspF[0][3] * cosy + gODMatrixPerspF[2][3] * -siny) * scalex);

    *(ai++) = (e1 & 0xffff0000) | ((e2 >> 16) & 0xffff);
    *(af++) = ((e1 << 16) & 0xffff0000) | (e2 & 0xffff);

    e1 = FTOFIX32((gODMatrixPerspF[0][0] * sinx * siny + gODMatrixPerspF[1][0] * cosx + gODMatrixPerspF[2][0] * sinx * cosy) * scaley);
    e2 = FTOFIX32((gODMatrixPerspF[0][1] * sinx * siny + gODMatrixPerspF[1][1] * cosx + gODMatrixPerspF[2][1] * sinx * cosy) * scaley);

    *(ai++) = (e1 & 0xffff0000) | ((e2 >> 16) & 0xffff);
    *(af++) = ((e1 << 16) & 0xffff0000) | (e2 & 0xffff);

    e1 = FTOFIX32((gODMatrixPerspF[0][2] * sinx * siny + gODMatrixPerspF[1][2] * cosx + gODMatrixPerspF[2][2] * sinx * cosy) * scaley);
    e2 = FTOFIX32((gODMatrixPerspF[0][3] * sinx * siny + gODMatrixPerspF[1][3] * cosx + gODMatrixPerspF[2][3] * sinx * cosy) * scaley);

    *(ai++) = (e1 & 0xffff0000) | ((e2 >> 16) & 0xffff);
    *(af++) = ((e1 << 16) & 0xffff0000) | (e2 & 0xffff);

    e1 = FTOFIX32((gODMatrixPerspF[0][0] * cosx * siny + gODMatrixPerspF[1][0] * -sinx + gODMatrixPerspF[2][0] * cosx * cosy) * scalex);
    e2 = FTOFIX32((gODMatrixPerspF[0][1] * cosx * siny + gODMatrixPerspF[1][1] * -sinx + gODMatrixPerspF[2][1] * cosx * cosy) * scalex);

    *(ai++) = (e1 & 0xffff0000) | ((e2 >> 16) & 0xffff);
    *(af++) = ((e1 << 16) & 0xffff0000) | (e2 & 0xffff);

    e1 = FTOFIX32((gODMatrixPerspF[0][2] * cosx * siny + gODMatrixPerspF[1][2] * -sinx + gODMatrixPerspF[2][2] * cosx * cosy) * scalex);
    e2 = FTOFIX32((gODMatrixPerspF[0][3] * cosx * siny + gODMatrixPerspF[1][3] * -sinx + gODMatrixPerspF[2][3] * cosx * cosy) * scalex);

    *(ai++) = (e1 & 0xffff0000) | ((e2 >> 16) & 0xffff);
    *(af++) = ((e1 << 16) & 0xffff0000) | (e2 & 0xffff);
    
    gSPMvpRecalc(dl++);
    
    gMoveWd(dl++, G_MW_MATRIX, G_MWO_MATRIX_XX_XY_I, mtx->m[0][0]);\
    gMoveWd(dl++, G_MW_MATRIX, G_MWO_MATRIX_XZ_XW_I, mtx->m[0][1]);\
    gMoveWd(dl++, G_MW_MATRIX, G_MWO_MATRIX_YX_YY_I, mtx->m[0][2]);\
    gMoveWd(dl++, G_MW_MATRIX, G_MWO_MATRIX_YZ_YW_I, mtx->m[0][3]);\
    gMoveWd(dl++, G_MW_MATRIX, G_MWO_MATRIX_ZX_ZY_I, mtx->m[1][0]);\
    gMoveWd(dl++, G_MW_MATRIX, G_MWO_MATRIX_ZZ_ZW_I, mtx->m[1][1]);\
    gMoveWd(dl++, G_MW_MATRIX, G_MWO_MATRIX_XX_XY_F, mtx->m[2][0]);\
    gMoveWd(dl++, G_MW_MATRIX, G_MWO_MATRIX_XZ_XW_F, mtx->m[2][1]);\
    gMoveWd(dl++, G_MW_MATRIX, G_MWO_MATRIX_YX_YY_F, mtx->m[2][2]);\
    gMoveWd(dl++, G_MW_MATRIX, G_MWO_MATRIX_YZ_YW_F, mtx->m[2][3]);\
    gMoveWd(dl++, G_MW_MATRIX, G_MWO_MATRIX_ZX_ZY_F, mtx->m[3][0]);\
    gMoveWd(dl++, G_MW_MATRIX, G_MWO_MATRIX_ZZ_ZW_F, mtx->m[3][1]);\
    
    dls[0] = dl;
    
    return 1;
}

#ifdef NON_MATCHING
// 0x800CB140 - NONMATCHING: 'f[2][2] = dist.z' line uses wrong FPR
sb32 func_ovl0_800CB140(Mtx *mtx, DObj *dobj, Gfx **dls)
{
    Camera *cam;
    DObj *attach_dobj;
    ftParts *ft_parts;
    Mtx44f f;
    Vec3f sp50;
    Vec3f dist;
    Vec3f sp38;
    f32 scale;

    attach_dobj = dobj->user_data.p;
    ft_parts = attach_dobj->user_data.p;
    
    func_ovl2_800EDBA4(attach_dobj);
    
    scale = sqrtf(SQUARE(ft_parts->mtx_translate[0][0]) + SQUARE(ft_parts->mtx_translate[0][1]) + SQUARE(ft_parts->mtx_translate[0][2]));
    
    if (scale == 0.0F)
    {
        while (TRUE)
        {
            syErrorPrintf("FPE : 0 div (adfDMatrixDirecXBillboardSca) \n");
            scManagerRunPrintGObjStatus();
        }
    }
    scale = 1.0F / scale;
    
    sp50.x = f[1][0] = ft_parts->mtx_translate[0][0] * scale;
    sp50.y = f[1][1] = ft_parts->mtx_translate[0][1] * scale;
    sp50.z = f[1][2] = ft_parts->mtx_translate[0][2] * scale;
    
    cam = CameraGetStruct(gOMObjCurrentCapture);
    
    lbVector_Vec3fSubtract(&dist, &cam->vec.eye, &cam->vec.at);
    
    if (lbCommonSim3D(&sp50, &dist) < 0.999F)
    {
        lbVector_Vec3fNormalizedCross(&sp50, &dist, &sp38);
        lbCommonCross3D(&sp50, &sp38, &dist);
    }
    else
    {
        dist.x = dist.y = dist.z = 0.0F;
        
        sp38 = dist;
    }
    f[0][0] = sp38.x;
    f[0][1] = sp38.y;
    f[0][2] = sp38.z;

    f[2][0] = dist.x;
    f[2][1] = dist.y;
    f[2][2] = dist.z;

    f[3][1] = f[3][2] = 0.0F;
    f[3][0] = 0.0F;
    
    syMatrixF2LFixedW(&f, mtx);
    
    return 0;
}
#else
#pragma GLOBAL_ASM("asm/nonmatchings/lb/lbcommon/func_ovl0_800CB140.s")
#pragma GLOBAL_ASM("asm/nonmatchings/lb/lbcommon/D_ovl0_800D5E10.s")
#endif

// 0x800CB2F0
sb32 func_ovl0_800CB2F0(Mtx *mtx, DObj *dobj, Gfx **dls)
{
    s32 unused;
    DObj *attach_dobj = dobj->user_data.p;
    
    func_ovl2_800EDBA4(attach_dobj);
    
    dobj->rotate.vec.f.z = (ftGetParts(attach_dobj)->mtx_translate[0][2] > 0.0F) ? 
    
    attach_dobj->rotate.vec.f.x : -attach_dobj->rotate.vec.f.x;

    return 1;
}

// 0x800CB360
void lbCommonDrawDObjScaleX(DObj *dobj)
{
    s32 unused[2];
    
    if (!(dobj->flags & DOBJ_FLAG_NORENDER))
    {
        f32 bak = gODScaleX;
        s32 status = gcPrepDObjMatrix(&gDisplayListHead[1], dobj);
        
        if ((dobj->display_list != NULL) && !(dobj->flags & DOBJ_FLAG_NOTEXTURE))
        {
            gcDrawMObjForDObj(dobj, &gDisplayListHead[1]);
            
            gSPDisplayList(gDisplayListHead[1]++, dobj->display_list);
        }        
        if (dobj->child != NULL)
        {
            lbCommonDrawDObjScaleX(dobj->child);
        }
        if (status != 0)
        {
            if ((dobj->parent == DOBJ_PARENT_NULL) || (dobj->sib_next != NULL))
            {
                gSPPopMatrix(gDisplayListHead[1]++, G_MTX_MODELVIEW);
            }
        }
        gODScaleX = bak;
    }
    if (dobj->sib_prev == NULL)
    {
        DObj *sibling_dobj = dobj->sib_next;
        
        while (sibling_dobj != NULL)
        {
            lbCommonDrawDObjScaleX(sibling_dobj);

            sibling_dobj = sibling_dobj->sib_next;
        }
    }
}

// 0x800CB4B0
void lbCommonDObjScaleXProcDraw(GObj *gobj)
{
    gODScaleX = 1.0F;
    
    lbCommonDrawDObjScaleX(DObjGetStruct(gobj));
}

// 0x800CB4E0
void lbCommonDrawDObjDefault(DObj *dobj)
{
    if (!(dobj->flags & DOBJ_FLAG_NORENDER))
    {
        s32 status = gcPrepDObjMatrix(&gDisplayListHead[0], dobj);
        
        if ((dobj->display_list != NULL) && !(dobj->flags & DOBJ_FLAG_NOTEXTURE))
        {
            gcDrawMObjForDObj(dobj, &gDisplayListHead[0]);
            
            gSPDisplayList(gDisplayListHead[0]++, dobj->display_list);
        }        
        if (dobj->child != NULL)
        {
            lbCommonDrawDObjDefault(dobj->child);
        }
        if (status != 0)
        {
            if ((dobj->parent == DOBJ_PARENT_NULL) || (dobj->sib_next != NULL))
            {
                gSPPopMatrix(gDisplayListHead[0]++, G_MTX_MODELVIEW);
            }
        }
    }
    if (dobj->sib_prev == NULL)
    {
        DObj *sibling_dobj = dobj->sib_next;
        
        while (sibling_dobj != NULL)
        {
            lbCommonDrawDObjDefault(sibling_dobj);

            sibling_dobj = sibling_dobj->sib_next;
        }
    }
}

// 0x800CB608
void lbCommonEjectGObjLinkedList(GObj *gobj)
{
    if (gobj->link_next != NULL)
    {
        lbCommonEjectGObjLinkedList(gobj->link_next);
    }
    gcEjectGObj(gobj);
}

// 0x800D5CAC
sb32 (*dLBCommonProcMatrixList[/* */])(/* */) =
{
	func_ovl0_800C96EC,
	func_ovl0_800C96EC,
	func_ovl0_800C9714,
	func_ovl0_800C9714,
	func_ovl0_800CA024,
	func_ovl0_800CA024,
	lbCommonRotScaProcMatrix,
	lbCommonRotScaProcMatrix,
	func_ovl0_800CA194,
	func_ovl0_800CA194,
	func_ovl0_800CA5C8,
	func_ovl0_800CA5C8,
	func_ovl0_800CAB48,
	func_ovl0_800CAB48,
	func_ovl0_800CB140,
	func_ovl0_800CB140,
	func_ovl0_800CB2F0,
	func_ovl0_800CB2F0,
	lbCommonFighterPartsProcMatrix,
	lbCommonFighterPartsProcMatrix,
	cmManagerLookAtProcMatrix,
	cmManagerPrepLookAtProcMatrix,
	cmManagerPlayerMagnifyProcMatrix,
	NULL,
	cmManageOrthoLookAtProcMatrix,
	NULL,
	func_ovl0_800C994C,
	func_ovl0_800C994C,
	func_ovl0_800C99CC,
	func_ovl0_800C99CC,
	func_ovl0_800C9F30,
	func_ovl0_800C9F30,
	func_ovl0_800C9F70,
	func_ovl0_800C9F70,
	grSectorArwingLaser3DProcMatrix,
	grSectorArwingLaser3DProcMatrix,
	cmManageOrthoLookAtProcMatrix,
	cmManagerPrepProjectionProcMatrix
};

// 0x800CB644
u8 lbCommonGetBitmapDecodeNibble(u8 index)
{
	u8 array[/* */] = { 0x00, 0x05, 0x0A, 0x0F };

	return array[index];
}

// 0x800CB674
void lbCommonDecodeBitmapSiz4b(u8 *bitmap_csr, u8 *bitmap_buf, u8 *bitmap_start)
{
    while (bitmap_csr >= bitmap_start)
    {
        u8 temp;
        
        bitmap_buf[0] = lbCommonGetBitmapDecodeNibble(*bitmap_csr & 3);
        bitmap_buf[0] |= lbCommonGetBitmapDecodeNibble((*bitmap_csr & 12) >> 2) << 4;

        bitmap_buf[-1] = lbCommonGetBitmapDecodeNibble((*bitmap_csr & 48) >> 4);

        temp = lbCommonGetBitmapDecodeNibble((*bitmap_csr & 192) >> 6);
        
        bitmap_csr--;

        bitmap_buf -= 2;

        bitmap_buf[1] |= temp << 4;
    }
}

// 0x800CB738
void lbCommonDecodeSpriteBitmapsSiz4b(Sprite *sprite)
{
    s32 n;
    Bitmap *bitmap;
    
    for (n = sprite->nbitmaps, bitmap = sprite->bitmap; n > 0; n--)
    {
        s32 res = (bitmap[n - 1].width_img / 2) * bitmap[n - 1].actualHeight;
            
        lbCommonDecodeBitmapSiz4b
        (
            (u8*) ((u8*)bitmap[n - 1].buf + (res / 2) - 1), 
            (u8*) ((u8*)bitmap[n - 1].buf + (res - 1)),
            (u8*) ((u8*)bitmap[n - 1].buf)
        );
    }
    sprite->bmsiz = G_IM_SIZ_4b;
}

// #pragma GLOBAL_ASM("asm/nonmatchings/lb/lbcommon/D_ovl0_800D5E10.s")

// 0x800CB7D4
void lbCommonDrawSObjBitmap
(
    Gfx **dls,
    SObj *sobj,
    Sprite *sprite,
    Bitmap *bitmap,
    s32 x, s32 y,
    s32 xx, s32 yy,
    s32 fs, s32 ft,
    s32 sx, s32 sy
)
{
    s32 rs, rt;
    s32 rxh, ryh;
    s32 rxl, ryl;
    Gfx *dl;
    s32 tex_width, tex_height;
    void *buf;

    if (bitmap->buf == NULL)
    {
        while (TRUE)
        {
            syErrorPrintf("drawBitMap: no bitmap data!\n");
            scManagerRunPrintGObjStatus();
        }
    }
    if (yy >= sLBCommonScissorYMin)
    {
        if (sprite->attr & SP_FASTCOPY)
        {
            yy--;
        }
        dl = dls[0];
        
        if (sprite->attr & SP_TEXSHIFT)
        {
            fs += 16;
            ft += 16;
        }
        tex_width = bitmap->width;
        tex_height = bitmap->actualHeight;
        
        if (x < sLBCommonScissorXMin)
        {
            rxh = sLBCommonScissorXMin * 4;
            rs = fs + (((sLBCommonScissorXMin - x) * sx) >> 5);
        }
        else
        {
            rxh = x * 4;
            rs = fs;
        }
        if (y < sLBCommonScissorYMin)
        {
            ryh = sLBCommonScissorYMin * 4;
            rt = ft + (((sLBCommonScissorYMin - y) * sy) >> 5);
        }
        else
        {
            ryh = y * 4;
            rt = ft;
        }
        if (xx >= sLBCommonScissorXMax)
        {
            rxl = sLBCommonScissorXMax * 4;
        }
        else rxl = xx * 4;
    
        if (yy >= sLBCommonScissorYMax)
        {
            ryl = sLBCommonScissorYMax * 4;
        }
        else ryl = yy * 4;
        
        if (bitmap->buf != sLBCommonPrevBitmapBuf)
        {
            switch (sprite->bmsiz)
            {
            case G_IM_SIZ_4b:
                gDPSetTextureImage(dl++, sprite->bmfmt, G_IM_SIZ_16b, 1, bitmap->buf);
                gDPSetTile
                (
                    dl++,
                    sprite->bmfmt,
                    G_IM_SIZ_16b,
                    0,
                    0,
                    G_TX_LOADTILE,
                    NULL,
                    sobj->cmt,
                    sobj->maskt,
                    G_TX_NOLOD,
                    sobj->cms,
                    sobj->masks,
                    G_TX_NOLOD
                );
                gDPLoadSync(dl++);
                gDPLoadBlock(dl++, G_TX_LOADTILE, 0, 0, (((bitmap->width_img * tex_height) + 3) >> 2) - 1, 0);
                gDPPipeSync(dl++);
                gDPSetTile
                (
                    dl++,
                    sprite->bmfmt,
                    G_IM_SIZ_4b, 
                    (((tex_width) >> 1) + 7) >> 3,
                    0,
                    G_TX_RENDERTILE,
                    NULL,
                    sobj->cmt,
                    sobj->maskt,
                    G_TX_NOLOD,
                    sobj->cms,
                    sobj->masks,
                    G_TX_NOLOD
                );
                gDPSetTileSize
                (
                    dl++,
                    G_TX_RENDERTILE,
                    0,
                    0,
                    ((tex_width)-1) << G_TEXTURE_IMAGE_FRAC,
                    ((tex_height)-1) << G_TEXTURE_IMAGE_FRAC
                );
                break;
                
            case G_IM_SIZ_8b:
                gDPSetTextureImage(dl++, sprite->bmfmt, G_IM_SIZ_8b_LOAD_BLOCK, 1, bitmap->buf);
                gDPSetTile
                (
                    dl++,
                    sprite->bmfmt,
                    G_IM_SIZ_8b_LOAD_BLOCK,
                    0,
                    0,
                    G_TX_LOADTILE,
                    NULL,
                    sobj->cmt,
                    sobj->maskt,
                    G_TX_NOLOD,
                    sobj->cms,
                    sobj->masks,
                    G_TX_NOLOD
                );
                gDPLoadSync(dl++);
                gDPLoadBlock(dl++, G_TX_LOADTILE, 0, 0, (((bitmap->width_img * tex_height) + 1) >> G_IM_SIZ_8b_SHIFT) - 1, 0);
                gDPPipeSync(dl++);
                gDPSetTile
                (
                    dl++,
                    sprite->bmfmt,
                    G_IM_SIZ_8b, 
                    ((tex_width * G_IM_SIZ_8b_LINE_BYTES) + 7) >> 3,
                    0,
                    G_TX_RENDERTILE,
                    NULL,
                    sobj->cmt,
                    sobj->maskt,
                    G_TX_NOLOD,
                    sobj->cms,
                    sobj->masks,
                    G_TX_NOLOD
                );
                gDPSetTileSize
                (
                    dl++,
                    G_TX_RENDERTILE,
                    0,
                    0,
                    ((tex_width)-1) << G_TEXTURE_IMAGE_FRAC,
                    ((tex_height)-1) << G_TEXTURE_IMAGE_FRAC
                );
                break;
                
            case G_IM_SIZ_16b:
                gDPSetTextureImage(dl++, sprite->bmfmt, G_IM_SIZ_16b_LOAD_BLOCK, 1, bitmap->buf);
                gDPSetTile
                (
                    dl++,
                    sprite->bmfmt,
                    G_IM_SIZ_16b_LOAD_BLOCK,
                    0,
                    0,
                    G_TX_LOADTILE,
                    NULL,
                    sobj->cmt,
                    sobj->maskt,
                    G_TX_NOLOD,
                    sobj->cms,
                    sobj->masks,
                    G_TX_NOLOD
                );
                gDPLoadSync(dl++);
                gDPLoadBlock(dl++, G_TX_LOADTILE, 0, 0, (((bitmap->width_img * tex_height) + 1) >> G_IM_SIZ_16b_SHIFT) - 2, 0);
                gDPPipeSync(dl++);
                gDPSetTile
                (
                    dl++,
                    sprite->bmfmt,
                    G_IM_SIZ_16b, 
                    ((tex_width * G_IM_SIZ_16b_LINE_BYTES) + 7) >> 3,
                    0,
                    G_TX_RENDERTILE,
                    NULL,
                    sobj->cmt,
                    sobj->maskt,
                    G_TX_NOLOD,
                    sobj->cms,
                    sobj->masks,
                    G_TX_NOLOD
                );
                gDPSetTileSize
                (
                    dl++,
                    G_TX_RENDERTILE,
                    0,
                    0,
                    ((tex_width)-1) << G_TEXTURE_IMAGE_FRAC,
                    ((tex_height)-1) << G_TEXTURE_IMAGE_FRAC
                );
                break;
                
            case G_IM_SIZ_32b:
                gDPSetTextureImage(dl++, G_IM_FMT_RGBA, G_IM_SIZ_32b_LOAD_BLOCK, 1, bitmap->buf);
                gDPSetTile
                (
                    dl++,
                    G_IM_FMT_RGBA,
                    G_IM_SIZ_32b_LOAD_BLOCK,
                    0,
                    0,
                    G_TX_LOADTILE,
                    NULL,
                    sobj->cmt,
                    sobj->maskt,
                    G_TX_NOLOD,
                    sobj->cms,
                    sobj->masks,
                    G_TX_NOLOD
                );
                gDPLoadSync(dl++);
                gDPLoadBlock(dl++, G_TX_LOADTILE, 0, 0, (((bitmap->width_img * tex_height) + 1) >> G_IM_SIZ_32b_SHIFT) - 2, 0);
                gDPPipeSync(dl++);
                gDPSetTile
                (
                    dl++,
                    G_IM_FMT_RGBA,
                    G_IM_SIZ_32b, 
                    ((tex_width * G_IM_SIZ_32b_LINE_BYTES) + 7) >> 3,
                    0,
                    G_TX_RENDERTILE,
                    NULL,
                    sobj->cmt,
                    sobj->maskt,
                    G_TX_NOLOD,
                    sobj->cms,
                    sobj->masks,
                    G_TX_NOLOD
                );
                gDPSetTileSize
                (
                    dl++,
                    G_TX_RENDERTILE,
                    0,
                    0,
                    ((tex_width)-1) << G_TEXTURE_IMAGE_FRAC,
                    ((tex_height)-1) << G_TEXTURE_IMAGE_FRAC
                );
                break;
            }
            sLBCommonPrevBitmapBuf = bitmap->buf;
        }        
        gSPTextureRectangle(dl++, rxh, ryh, rxl, ryl, 0, rs, rt, sx, sy);

        gDPPipeSync(dl++);
        
        dls[0] = dl;
    }
}

// 0x800CC118
void lbCommonPrepSObjSpriteAttrs(Gfx **dls, SObj *sobj)
{
    Gfx *dl = dls[0];
    Sprite *sprite = &sobj->sprite;
    
    if (sLBCommonExternSpriteAttr & SP_ARGUMENT)
    {
        gDPPipeSync(dl++);
        
        if (sprite->attr & SP_FASTCOPY)
        {
            gDPSetCycleType(dl++, G_CYC_COPY);
        }
        else gDPSetCycleType(dl++, G_CYC_1CYCLE);
        
        if (sprite->attr & SP_TRANSPARENT)
        {
            gDPSetRenderMode(dl++, G_RM_XLU_SURF, G_RM_XLU_SURF2);
        }
        else if (sprite->attr & SP_TRANSPARENT)
        {
            gDPSetRenderMode(dl++, G_RM_CLD_SURF, G_RM_CLD_SURF2);
        } 
        else gDPSetRenderMode(dl++, G_RM_OPA_SURF, G_RM_OPA_SURF2);
        
        if (sprite->attr & SP_TEXSHIFT)
        {
            gDPSetTextureFilter(dl++, G_TF_AVERAGE);
        }
        else gDPSetTextureFilter(dl++, G_TF_BILERP);
        
        if (sprite->bmfmt != G_IM_FMT_CI)
        {
            gDPSetTextureLUT(dl++, G_TT_NONE);
        }
    }
    else
    {
        if (sLBCommonExternSpriteAttr & SP_EXTERN)
        {
            sLBCommonExternSpriteAttr = ~sprite->attr;
        }
        if (sprite->attr & SP_EXTERN)
        {
            sLBCommonExternSpriteAttr = sprite->attr;
        }
        if (sprite->attr != sLBCommonExternSpriteAttr)
        {
            if (sprite->attr & SP_FASTCOPY)
            {
                if (!(sLBCommonExternSpriteAttr & SP_FASTCOPY))
                {
                    gDPSetCycleType(dl++, G_CYC_COPY);
                }
            }
            else if (sLBCommonExternSpriteAttr & SP_FASTCOPY)
            {
                gDPSetCycleType(dl++, G_CYC_1CYCLE);
            }
            if (sprite->attr & SP_TRANSPARENT)
            {
                if (!(sLBCommonExternSpriteAttr & SP_TRANSPARENT))
                {
                    gDPSetRenderMode(dl++, G_RM_XLU_SURF, G_RM_XLU_SURF2);
                }
            }
            else if (sprite->attr & SP_CLOUD)
            {
                if (!(sLBCommonExternSpriteAttr & SP_CLOUD))
                {
                    gDPSetRenderMode(dl++, G_RM_CLD_SURF, G_RM_CLD_SURF2);
                }
            }
            else if (sLBCommonExternSpriteAttr & (SP_CLOUD | SP_TRANSPARENT))
            {
                gDPSetRenderMode(dl++, G_RM_OPA_SURF, G_RM_OPA_SURF2);
            }
            if (sprite->attr & SP_TEXSHIFT)
            {
                if (!(sLBCommonExternSpriteAttr & SP_TEXSHIFT))
                {
                    gDPSetTextureFilter(dl++, G_TF_AVERAGE);
                }
            }
            else if (sLBCommonExternSpriteAttr & SP_TEXSHIFT)
            {
                gDPSetTextureFilter(dl++, G_TF_BILERP);
            }
        }
    }
    if (sprite->bmfmt != sLBCommonExternBitmapFmt)
    {
        switch (sprite->bmfmt)
        {
        case G_IM_FMT_I:
            gDPSetPrimColor(dl++, 0, 0, sprite->red, sprite->green, sprite->blue, sprite->alpha);
            gDPSetCombineLERP(dl++, 0, 0, 0, PRIMITIVE, 0, 0, 0, TEXEL0, 0, 0, 0, PRIMITIVE, 0, 0, 0, TEXEL0);
            break;
            
        case G_IM_FMT_IA:
            gDPSetPrimColor(dl++, 0, 0, sprite->red, sprite->green, sprite->blue, sprite->alpha);
            gDPSetEnvColor(dl++, sobj->env_color.r, sobj->env_color.g, sobj->env_color.b, sobj->env_color.a);
            gDPSetCombineLERP(dl++, PRIMITIVE, ENVIRONMENT, TEXEL0, ENVIRONMENT, TEXEL0, 0, PRIMITIVE, 0, PRIMITIVE, ENVIRONMENT, TEXEL0, ENVIRONMENT, TEXEL0, 0, PRIMITIVE, 0);
            break;

        case G_IM_FMT_CI:
            gDPSetTextureLUT(dl++, G_TT_RGBA16);
            gDPLoadTLUT(dl++, sprite->nTLUT, sprite->startTLUT + 256, sprite->LUT);
            gDPLoadSync(dl++);

            /* fallthrough */

        default:
            gDPSetCombineMode(dl++, G_CC_DECALRGBA, G_CC_DECALRGBA);
            break;
        }
        if (sprite->bmfmt != G_IM_FMT_CI)
        {
            if (sLBCommonExternBitmapFmt == G_IM_FMT_CI)
            {
                gDPSetTextureLUT(dl++, G_TT_NONE);
            }
        }
    }
    else switch (sprite->bmfmt)
    {
    case G_IM_FMT_I:
        gDPSetPrimColor(dl++, 0, 0, sprite->red, sprite->green, sprite->blue, sprite->alpha);
        break;
        
    case G_IM_FMT_IA:
        gDPSetPrimColor(dl++, 0, 0, sprite->red, sprite->green, sprite->blue, sprite->alpha);
        gDPSetEnvColor(dl++, sobj->env_color.r, sobj->env_color.g, sobj->env_color.b, sobj->env_color.a);
        break;

    case G_IM_FMT_CI:
        if (sprite->LUT != sLBCommonPrevSpriteLUT)
        {
            gDPLoadTLUT(dl++, sprite->nTLUT, sprite->startTLUT + 256, sprite->LUT);
            gDPLoadSync(dl++);
        }
        break; 
    }
    dls[0] = dl;
}

#ifdef NON_MATCHING
// 0x800CC818 - NONMATCHING: many regswaps, but appears to be equivalent
void lbCommonPrepSObjDraw(Gfx **dls, SObj *sobj)
{
    Sprite *sprite;
    Bitmap *bitmap;
    f32 fheight;
    f32 fy;
    s32 fs = 0;
    s32 yy;
    s32 ft = 0;
    s32 sx = 0x1000;
    s32 sy = 0x400;
    s32 x;
    s32 xx;
    s32 n;
    s32 unused2;
    s32 y;
    s32 tempy;
    s32 tempft;
    s32 unused[3];
    f32 scaley;
    f32 posx, posy;
    
    sprite = &sobj->sprite;
    
    if (sprite->scalex < 0.0001F)
    {
        return;
    }
    if (sprite->scaley < 0.0001F)
    {
        return;
    }
    bitmap = sprite->bitmap;
    
    if (bitmap != NULL)
    {
        posx = sobj->pos.x;
        x = (posx < 0.0F) ? (posx - 0.9999F) : (posx);

        posy = sobj->pos.y;
        tempy = (sobj->pos.y < 0.0F) ? (sobj->pos.y - 0.9999F) : (sobj->pos.y);
        
        if ((x < sLBCommonScissorXMax) && (tempy < sLBCommonScissorYMax))
        {
            s32 tempxx = (sobj->cms == 2) ? (sprite->width) : (sobj->lrs);
            yy = (sobj->cmt == 2) ? (sprite->bmheight) : (sobj->lrt);
            
            if (sprite->attr & SP_FASTCOPY)
            {
                xx = posx + tempxx;
                
                y = tempy;
                
                if (xx >= sLBCommonScissorXMin)
                {
                    xx--;

                    if (sprite->nbitmaps == 1)
                    {
                        lbCommonDrawSObjBitmap(dls, sobj, sprite, bitmap, x, y, xx, tempy + yy, (s16)-fs, (s16)-ft, sx, sy);
                    }
                    else
                    {
                        for (n = 0; n < sprite->nbitmaps; n++, bitmap++)
                        {
                            lbCommonDrawSObjBitmap(dls, sobj, sprite, bitmap, x, y, xx, y + yy, (s16)-fs, (s16)-ft, sx, sy);
                            y += yy;
                        }
                    }
                }
            }
            else
            {
                s32 n;
                f32 scalex = sprite->scalex;
                
                xx = (posx + (tempxx * scalex)) + 0.9999F;
                
                if (xx >= sLBCommonScissorXMin)
                {
                    f32 fposx = posx - x;
                    f32 fposy = sobj->pos.y - tempy;
                    
                    scaley = sprite->scaley;
                    
                    if (sprite->nbitmaps == 1)
                    {
                        sx = (1024.0F / scalex) + 0.5F;
                        fs = ((sx * fposx) + 16) / 32;
                        
                        sy = (1024.0F / scaley) + 0.5F;
                        ft = ((sy * fposy) + 16) / 32;
                        
                        y = (sobj->pos.y + (yy * scaley)) + 0.9999F;
                        
                        lbCommonDrawSObjBitmap(dls, sobj, sprite, bitmap, x, tempy, xx, y, (s16)-fs, (s16)-ft, sx, sy);
                    }
                    else
                    {
                        fheight = sprite->bmHreal * scaley;
                        y = fy = sobj->pos.y + (yy * scaley);
                        
                        sx = (1024.0F / scalex) + 0.5F;
                        sy = (1024.0F / scaley) + 0.5F;
                        
                        fs = ((sx * fposx) + 16) / 32;
                        ft = ((sy * fposy) + 16) / 32;
                        
                        lbCommonDrawSObjBitmap(dls, sobj, sprite, bitmap, x, tempy, xx, y, (s16)-fs, (s16)-ft, sx, sy);
                        
                        bitmap++;
                        
                        for (n = 1; n < (sprite->nbitmaps - 1); n++, bitmap++)
                        {
                            tempft = (sy * (fy - y));
                            ft = (tempft + 16) / 32;
                            
                            tempy = y;
                            y = fy + fheight;
                            
                            lbCommonDrawSObjBitmap(dls, sobj, sprite, bitmap, x, tempy, xx, y, (s16)-fs, (s16)-ft, sx, sy);
                            
                            fy += yy * scaley;
                        }
                        tempft = (sy * (fy - y));
                        ft = (tempft + 16) / 32;
                        
                        tempy = y;
                        y = ((bitmap->actualHeight * scaley) + fy) + 0.9999F;
                        
                        lbCommonDrawSObjBitmap(dls, sobj, sprite, bitmap, x, tempy, xx, y, (s16)-fs, (s16)-ft, sx, sy);
                    }
                }
            }
        }
    }
}
#else
#pragma GLOBAL_ASM("asm/nonmatchings/lb/lbcommon/lbCommonPrepSObjDraw.s")
#endif

// 0x800CCEAC
void lbCommonClearExternSpriteParams(void)
{
    sLBCommonExternSpriteAttr = SP_ARGUMENT;
    sLBCommonExternBitmapFmt = -1;
    
    sLBCommonPrevBitmapBuf = NULL;
    sLBCommonPrevSpriteLUT = NULL;
}

// 0x800CCED8
void lbCommonSetExternSpriteParams(Sprite *sprite)
{
    sLBCommonExternSpriteAttr = sprite->attr;
    sLBCommonExternBitmapFmt = sprite->bmfmt;
    sLBCommonPrevSpriteLUT = sprite->LUT;
}

// 0x800CCF00
void lbCommonDrawSObjAttr(GObj *gobj)
{
    SObj *sobj = SObjGetStruct(gobj);
    
    while (sobj != NULL)
    {
        if (!(sobj->sprite.attr & SP_HIDDEN))
        {
            lbCommonPrepSObjSpriteAttrs(gDisplayListHead, sobj);
            lbCommonPrepSObjDraw(gDisplayListHead, sobj);
            lbCommonSetExternSpriteParams(&sobj->sprite);
        }
        sobj = sobj->next;
    }
}

// 0x800CCF74
void lbCommonDrawSObjNoAttr(GObj *gobj)
{
    SObj *sobj = SObjGetStruct(gobj);
    
    while (sobj != NULL)
    {
        if (!(sobj->sprite.attr & SP_HIDDEN))
        {
            lbCommonPrepSObjDraw(gDisplayListHead, sobj);
            lbCommonClearExternSpriteParams();
        }
        sobj = sobj->next;
    }
}

// 0x800CCFDC
SObj* lbCommonMakeSObjForGObj(GObj *gobj, Sprite *sprite)
{
    SObj *sobj;

    if (sprite->bmsiz == G_IM_SIZ_4c)
    {
        lbCommonDecodeSpriteBitmapsSiz4b(sprite);
    }
    sobj = gcAddSObjForGObj(gobj, sprite);
    
    sobj->env_color.r =
    sobj->env_color.g =
    sobj->env_color.b =
    sobj->env_color.a = 0x00;
    
    sobj->maskt = sobj->masks = 0;
    
    sobj->cmt = sobj->cms = 2;
    
    sobj->pos.x = sobj->pos.y = 0.0F;
}

// 0x800CD050
GObj* lbCommonMakeSpriteGObj
(
    u32 id,
    void (*proc_run)(GObj*),
    s32 link,
    u32 link_order,
    void (*proc_draw)(GObj*),
    s32 dl_link,
    u32 dl_link_order,
    u32 cam_tag,
    Sprite *sprite,
    u8 gobjproc_kind,
    void (*proc)(GObj*),
    u32 gobjproc_priority
)
{
    GObj *gobj = gcMakeGObjSPAfter(id, proc_run, link, link_order);
        
    if (gobj == NULL)
    {
        return NULL;
    }
    gcAddGObjDisplay(gobj, proc_draw, dl_link, dl_link_order, cam_tag);
    
    lbCommonMakeSObjForGObj(gobj, sprite);
        
    if (proc != NULL)
    {
        gcAddGObjProcess(gobj, proc, gobjproc_kind, gobjproc_priority);
    }
    return gobj;
}

// 0x800CD0D0
void lbCommonStartSprite(Gfx **dls)
{
    Gfx *dl = dls[0];
    
    lbCommonClearExternSpriteParams();
    
    gDPPipeSync(dl++);
    gDPSetCycleType(dl++, G_CYC_1CYCLE);
    gDPSetBlendColor(dl++, 0x00, 0x00, 0x00, 0x08)
    gDPSetAlphaCompare(dl++, G_AC_THRESHOLD);
    gDPSetTexturePersp(dl++, G_TP_NONE);
    gDPSetTextureFilter(dl++, G_TF_BILERP);
    gDPSetTextureConvert(dl++, G_TC_FILT);
    gDPSetTextureDetail(dl++, G_TD_CLAMP);
    gDPSetTextureLOD(dl++, G_TL_TILE);
    gDPSetTextureLUT(dl++, G_TT_NONE);
    gDPSetRenderMode(dl++, G_RM_OPA_SURF, G_RM_OPA_SURF2);
    
    dls[0] = dl;
}

// 0x800CD1F0
void lbCommonSetSpriteScissor(s32 xmin, s32 xmax, s32 ymin, s32 ymax)
{
    sLBCommonScissorXMin = xmin;
    sLBCommonScissorYMin = ymin;
    sLBCommonScissorXMax = xmax;
    sLBCommonScissorYMax = ymax;
}

// 0x800CD214
void lbCommonFinishSprite(Gfx **dls)
{
    Gfx *dl = dls[0];
    
    gDPSetCombineMode(dl++, G_CC_SHADE, G_CC_SHADE);
    gDPSetAlphaCompare(dl++, G_AC_NONE);
    gDPSetTexturePersp(dl++, G_TP_PERSP);

    if (sLBCommonExternSpriteAttr & SP_TRANSPARENT)
    {
        gDPSetRenderMode(dl++, G_RM_OPA_SURF, G_RM_OPA_SURF2);
    }
    if (sLBCommonExternBitmapFmt == G_IM_FMT_CI)
    {
        gDPSetTextureLUT(dl++, G_TT_NONE);
    }
    dls[0] = dl;
}

// 0x800CD2CC
void lbCommonScissorSpriteCamera(GObj *gobj)
{
    Camera *cam = CameraGetStruct(gobj);
    Vp_t *viewport = &cam->viewport.vp;
    s32 ulx = (viewport->vtrans[0] / 4) - (viewport->vscale[0] / 4);
    s32 uly = (viewport->vtrans[1] / 4) - (viewport->vscale[1] / 4);
    s32 lrx = (viewport->vtrans[0] / 4) + (viewport->vscale[0] / 4);
    s32 lry = (viewport->vtrans[1] / 4) + (viewport->vscale[1] / 4);
    
    if (ulx < (gSYDisplayResWidth / GS_SCREEN_WIDTH_DEFAULT) * 10)
    {
        ulx = (gSYDisplayResWidth / GS_SCREEN_WIDTH_DEFAULT) * 10;
    }
    if (uly < (gSYDisplayResHeight / GS_SCREEN_HEIGHT_DEFAULT) * 10)
    {
        uly = (gSYDisplayResHeight / GS_SCREEN_HEIGHT_DEFAULT) * 10;
    }
    if (lrx > gSYDisplayResWidth - ((gSYDisplayResWidth / GS_SCREEN_WIDTH_DEFAULT) * 10))
    {
        lrx = gSYDisplayResWidth - ((gSYDisplayResWidth / GS_SCREEN_WIDTH_DEFAULT) * 10);
    }
    if (lry > gSYDisplayResHeight - ((gSYDisplayResHeight / GS_SCREEN_HEIGHT_DEFAULT) * 10))
    {
        lry = gSYDisplayResHeight - ((gSYDisplayResHeight / GS_SCREEN_HEIGHT_DEFAULT) * 10);
    }
    lbCommonStartSprite(gDisplayListHead);
    lbCommonSetSpriteScissor(ulx, lrx, uly, lry);

    func_80017B80(gobj, (cam->flags & 8) ? 1 : 0);
    lbCommonFinishSprite(gDisplayListHead);
}

// 0x800CD440
void lbCommonInitCameraOrtho(Camera *cam, u8 tk, u8 arg2)
{
    OMMtx *ommtx = gcAddOMMtxForCamera(cam, tk, arg2);
    
    cam->projection.ortho = dOMOrthoDefault;
    cam->projection.ortho.ommtx = ommtx;
}

// 0x800CD4C0
void lbCommonInitCameraPersp(Camera *cam, u8 tk, u8 arg2)
{
    OMMtx *ommtx = gcAddOMMtxForCamera(cam, tk, arg2);
    
    cam->projection.persp = dOMPerspDefault;
    cam->projection.persp.ommtx = ommtx;
}

// 0x800CD538
void lbCommonInitCameraVec(Camera *cam, u8 tk, u8 arg2)
{
    OMMtx *ommtx = gcAddOMMtxForCamera(cam, tk, arg2);
    
    cam->vec = dOMCameraVecDefault;
    cam->vec.ommtx = ommtx;
}

// 0x800CD5AC
void lbCommonCross3D(Vec3f *a, Vec3f *b, Vec3f *out)
{
	out->x = a->y * b->z - a->z * b->y;
	out->y = a->z * b->x - a->x * b->z;
	out->z = a->x * b->y - a->y * b->x;
}
